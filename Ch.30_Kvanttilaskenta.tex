\chapter{Kvanttilaskenta}
Seuraavaksi käsittelemme kvanttilaskentaa ja sitä hyödyntäviä kvanttitietokoneita. Lisäksi tutustumme nykyisten salausjärjestelmien kvanttiturvallisuuteen sekä Shorin algoritmiin ja kuinka se jakaa suuret kokonaisluvut tehokkaasti tekijöihinsä.

\section{Kvanttilaskenta ja kvanttitietokoneet}
Klassisessa tietokoneessa informaatio esitetään bitteinä ja yksi bitti on tiedon perusyksikkö (\cite{doi:10.1080/23742917.2016.1226650}). Yksittäinen bitti voi saada vain yhden diskreetin arvon kerrallaan ja näitä arvoja kuvataan yleensä arvoilla 0 ja 1. Bitti voi siis olla arvoltaan vuorostaan joko 0 tai 1. Klassisessa tietokoneessa näitä bittejä käsitellään loogisten porttien kautta.

Kvanttitietokoneen laskennan perusyksikkö taas on kubitti eli kvanttibitti (\cite{doi:10.1080/23742917.2016.1226650}). Kvanttitietokoneessa kubitteja käsitellään kvanttiporttien kautta. Kubitti voi olla bitin tavoin myös kahdessa eri tilassa. Merkitään näitä tiloja symboleilla
$\ket{0}$ ja $\ket{1}$.\footnote{Kvanttimekaniikassa notaatiota $\ket{}$ kutsutaan Diracin notaatioksi. Se on yleinen notaatio kvanttimekaniikassa tarkoittaen tilaa (\cite{nielsen2001quantum}).} Kubitti eroaa tavallisesta bitistä siten, että se voi olla tilojen $\ket{0}$ tai $\ket{1}$ sijaan superpositiotilassa. Tämä tarkoittaa siis sitä, että mittauksen aikana kubitti voi olla arvoltaan 0 tai 1, mutta laskennan aikana se on yhtä aikaa sekä 0 että 1. Eli tilat $\ket{0}$ ja $\ket{1}$ voivat esiintyä yhtä aikaa. Superpositiotilassa olevalle kubitille tehty operaatio vaikuttaa kumpaankin arvoon samanaikaisesti (\cite{mavroeidis2018impact}). Kubitit voivat myös lomittua keskenään, jota kutsutaan kvanttilomittumiseksi (\emph{Quantum entanglement}). Kun kaksi kubittia lomittuvat keskenään, sen jälkeen niiden tiloja ei voi enää kuvailla riippumatta toisistaan. Sen sijaan ne kuvataan yhtenä objektina, jolla on neljä erillistä tilaa.

Kvanttitietokoneen tehokkaamman laskentatehon mahdollistaa siis nämä edellä mainitut kvanttimekaniikan ilmiöt, kvanttisuperpositio ja kvanttilomittuminen (\cite{mavroeidis2018impact}). Kvanttitietokoneella on siis mahdollista suorittaa laskentaa samanaikaisesti eli rinnakkain jokaiselle kubitin eri tilalle (\cite{doi:10.1080/23742917.2016.1226650}). Tätä kutsutaan kvanttirinnakkaisuudeksi (\emph{Quantum parallelism}). Kvanttitietokone joka käyttää laskentaan $n$ kubittia mahdollistaa samanaikaisesti $2^{n}$ rinnakkaisesti suoritettavaa operaatiota (\cite{mavroeidis2018impact}). Esimerkiksi kolmella kubitilla laskentaa tekevä kvanttitietokone mahdollistaa 8 eri tilaa samanaikaisesti (\cite{doi:10.1080/23742917.2016.1226650}). Kolmella bitillä laskentaa tekevä klassinen tietokone mahdollistaa myös 8 eri tilaa, mutta vain yksi näistä kahdeksasta tilasta voi olla kerrallaan voimassa.  Kvanttitietokone tarjoaa siis eksponentiaalisesti nopeamman laskentatehon. Tätä eksponentiaalista laskentatehoa hyödyntävät algoritmit uhkaavat muun muassa julkisen avaimen salausta.

Täytyy kuitenkin huomata, että kvanttitietokoneet ovat ylivoimaisia klassisiin tietokoneisiin verrattuna vasta silloin kun ongelmaan voidaan soveltaa algoritmia, joka osaa hyödyntää kvanttitietokoneiden mahdollistamaa kvanttirinnakkaisuutta (\cite{mavroeidis2018impact}). Esimerkiksi kertolaskujen laskemisessa kvanttitietokone ei juuri tuo huomattavaa etua verrattuna klassisiin tietokoneisiin.

Nykypäivän kvanttitietokoneet ovat vielä kehitysvaiheessa (\cite{doi:10.1080/23742917.2016.1226650}). Ne vaativat suuren ja kalliin infrastruktuurin ympärilleen muun muassa jäähdytystä ja sähkömagneettiselta säteilyltä suojautumista varten. Kuitenkin tilanne oli aikoinaan samanlainen kun klassiset tietokoneet alkoivat ilmaantumaan. Tulevaisuudessa on siis odotettavissa, että kvanttitietokoneiden fyysinen koko ja vaatima infrastruktuuri tulee pienentymään.

\section{Nykyisten salausjärjestelmien kvanttiturvallisuus}
Käsitellään seuraavaksi kappaleessa 2 mainittujen nykypäivän salausjärjestelmien kvanttiturvallisuutta.

 Symmetrinen salaus on itsessään kvanttiturvallinen, koska niiden murtamiseen käytetään yleensä väsytyshyökkäystä (\emph{brute-force attack}) (\cite{mavroeidis2018impact}.) Väsytyshyökkäyksellä tarkoitetaan kaikkien mahdollisten vaihtoehtojen, esimerkiksi salausavaimien, systemaattista kokeilua. %ehkä viite
Toistaiseksi ei ole löydetty kvanttialgoritmeja, jotka murtaisivat symmetristä salausta käyttäviä järjestelmiä huomattavan tehokkaasti siten, että ne olisi uhattuna muuttua turvattomiksi. Kuitenkin Groverin algoritmia hyödyntämällä on mahdollista nopeuttaa kvanttitietokoneella tehtyjä väsytyshyökkäyksiä.
 
 Lyhyesti Groverin algoritmi on kvanttialgoritmi, jota käytetään tiedon hakemiseen (\cite{hayward2008quantum}). Groverin algoritmi löytää \emph{N}-kokoisesta järjestämättömästä listasta halutun alkion $\sqrt{N}$ askeleella. Klassisilla tietokoneilla ja algoritmeilla tällaisessa tehtävässä menee aina vähintään $N$ askelta. Siten Groverin algoritmi tuo neliöllisen nopeutuksen kvanttitietokoneella tehtyihin brute-force hyökkäyksiin (\cite{mavroeidis2018impact}). Kvanttitietokone joka käyttää Groverin algoritmia \emph{n}-bittisen salausavaimen purkamiseen laskee avaimen $\sqrt{2^{n}} = 2^{n/2}$ operaatiolla. Tällöin esimerkiksi 128-bittinen AES-salaus antaisi 64-bittisen suojauksen. Toisaalta näitä hyökkäyksiä voidaan hidastaa esimerkiksi tuplaamalla salausavaimen käyttämä bittien määrä. Tällöin vaadittavien kokeilujen määrä kasvaa eksponentiaalisesti ja kaikkien mahdollisten vaihtoehtojen kokeileminen vie erittäin pitkän ajan. Lohkosalaukseen perustuvia salausjärjestelmiä AES-192 ja AES-256 pidetään kvanttiturvallisina nyt ja jatkossa (\cite{mavroeidis2018impact}). Nykypäivänä 80-bittistä suojausta pidetään turvallisena rajana klassisella tietokoneella.
 
  Tiivistefunktiot ovat symmetrisen salauksen tapaan jo itsessään kvanttiturvallisia (\cite{mavroeidis2018impact}). Tiivistefunktiot muodostavat lohkosalauksen tapaan tietyn mittaisen bittijonon tiivisteen muodossa. Groverin algoritmia hyödyntäen on mahdollista tehdä hyökkäys tiivistefunktioita vastaan löytämällä törmäys (\emph{collision}) kahden tiivisteen välillä. Törmäyksellä tarkoitetaan tilannetta milloin kaksi eri syötettä antavat saman tiivisteen. %ehkä viite?
 Groverin algoritmilta voi suojautua pidentämällä tiivisteen pituutta. Turvallinen raja on, että \emph{n}-bitin suojaukseen tarvitaan 3\emph{n}-bittiä pitkä tiiviste. Esimerkiksi SHA-2 ja SHA-3 standardin tiivistefunktiot 256-bittiä pitkillä tiivisteillä ovat kvanttiturvallisia (\cite{mavroeidis2018impact, buchmann2016post}).
 
 Kuten kappaleessa 2 mainittiinkin, nykyinen julkisen avaimen salaus ja digitaalisen allekirjoittamisen menetelmät eivät ole kvanttiturvallisia edes suurilla avaimilla Shorin algoritmin myötä.

\section{Shorin algoritmi}
Vuonna 1994 Peter Shor esitteli Shorin algoritmin, jolla julkisen avaimen salaukseen liittyvät matemaattiset ongelmat, diskreetin logaritmin laskeminen ja suurten kokonaislukujen tekijöihinjako, voidaan ratkaista tehokkaasti eli polynomisessa ajassa (\cite{doi:10.1137/S0036144598347011}). Käsittelemme tässä kappaleessa ainoastaan kuinka Shorin algoritmi jakaa suuria kokonaislukuja tekijöihinsä, diskreetin logaritmin laskemista Shorin algoritmin avulla ei käsitellä.

Shorin algoritmin tehokkuus perustuu siihen kuinka se hyödyntää edellä mainittua kvanttirinnakkaisuutta. Kvanttitietokoneella Shorin algoritmi suorittaa eksponentiaalisen määrän operaatioita yhdessä askeleessa mikä taas vaatisi klassisella tietokoneella eksponentiaalisen määrän aikaa.


%\iffalse
Shorin algoritmin toiminta perustuu lukuteoriaan (\cite{hayward2008quantum}).
Olkoon meillä funktio
\begin{align*}
    F(a) = x^{a} \mod n,
\end{align*}
joka on jaksollinen kun $x$ on suhteellinen alkuluku\footnote{$x$ ja $n$ ovat silloin keskenään suhteellisia alkulukuja kun niiden suurin yhteinen tekijä on 1.} $n$:n kanssa ja $n$ on nyt luku jonka tahdomme jakaa tekijöihin. Koska $F(a)$ on jaksollinen funktio\footnote{Jaksollinen funktio tarkoittaa funktiota, joka toistuu samanlaisena tietyn jakson välein.}, niin sillä on tällöin jokin jakso $r$. Shorin algoritmi siis yrittää löytää $r$:n eli funktion $F(a) = x^{a} \mod n$ jakson. Tiedetään, että 
\begin{align*}
    \begin{split}
    & x^{0} \mod n = 1 \; \text{koska} \;  x^0 = 1 \; \text{joten} \\
    & x^{r} \mod n = 1 \; \text{ja} \\
    & x^{2r} \mod n = 1 \\
    & \; \text{ja niin edelleen kun $r$ saa monikertoja.}
    \end{split}
\end{align*}
Siten voidaan johtaa
\begin{align*}
    \begin{split}
    x^{r} & \equiv 1 \mod n \\
    (x^{r/2})^{2} = x^{r} & \equiv 1 \mod n \\
    (x^{r/2})^{2} - 1 & \equiv 0 \mod n
    \end{split}
\end{align*}
ja jos $r$ on parillinen niin
\begin{align*}
    (x^{r/2} - 1)(x^{r/2} + 1) \equiv 0 \mod n.
\end{align*}

Nyt $(x^{r/2} - 1)(x^{r/2} + 1)$ on $n$:n, eli luvun jonka haluamme jakaa tekijöihin, monikerta (\cite{hayward2008quantum}). Joten jos $\lvert x^{r/2} \rvert$ ei ole 1, niin ainakin toisella $(x^{r/2} - 1), (x^{r/2} + 1)$ on sama tekijä kuin $n$:llä. Nyt laskemalla $syt(x^{r/2} - 1, n)$ ja $syt(x^{r/2} + 1, n)$ saadaan $n$:n tekijä.

Simuloidaan nyt Eukleideen algoritmia siten että $n = 15$ ja se on luku jonka haluamme jakaa tekijöihin.
\begin{enumerate}
    \item Valitaan suhteellinen alkuluku. Valitaan 11, koska $syt(11,15) = 1$.
    
    \item Ryhdytään laskemaan $x^{a} \equiv 1 \mod n$, missä $a \in \mathbb{N}$.
    
    \begin{enumerate}
    
        \item $11^{1} \equiv 1 \mod 15 = 0$ kokonaista ja jakojäännöksenä 11.
        
        \item $11^{2} \equiv 1 \mod 15 = 121$ eli 8 kokonaista ja jakojäännöksenä 1.
        
        \item $11^{3} \equiv 1 \mod 15 = 1331$ eli 88 kokonaista ja jakojäännöksenä 11.
    \end{enumerate}
    
    \item Jatketaan näin korottamalla $x = 11$ aina korkeampiin potensseihin. Jakojäännös jaettaessa luvulla 15 vaihtelee antaen joko luvun 1 tai 11.
    
    \item Saamme nyt jaksoksi $r = 2$, koska kun lukua 11 jaetaan luvulla 15 saamme aina jakojäännökseksi joko 1 tai 11.
    
    \item Lasketaan nyt $x^{r/2}$, jolloin saadaan $x^{r/2} = 11^{2/2} = 11$.
    
    \item Lasketaan nyt $(x^{r/2}-1)$ ja $(x^{r/2}+1)$, jolloin saadaan $(11^{2/2} - 1) = (11 - 1) = 10$ ja $(11^{2/2} + 1) = (11 + 1) = 12$.
    
    \item Lasketaan $syt(10,15)$ ja $syt(12,15)$, jolloin saadaan $syt(10,15) = 5$ ja $syt(12,15) = 3$ ja huomataan, että 3 ja 5 ovat alkuluvut jotka muodostavat luvun 15.
    
\end{enumerate}
%\fi

Ongelmana nyt on, että kun $n$ kasvaa hyvin suureksi, niin jakson $r$ selvittäminen funktiolla $F(a)$ käy hyvin hankalaksi (\cite{doi:10.1080/23742917.2016.1226650}). Klassisilla tietokoneilla tämän ratkaisemiseen käytetään nopeita Fourier-muunnoksia (\emph{Fast-Fourier Transform, FFT}), mutta suurilla $n$:n arvoilla niiden laskeminen on hyvin epäkäytännöllistä. Kuten aiemmin mainittiin Shorin algoritmi ratkaisee jakson $r$ etsimisen tehokkaasti hyödyntäen laskennassaan kvanttirinnakkaisuutta. Jakson $r$ määrittäminen on ainut kohta algoritmissa, jossa tarvitaan kvanttitietokonetta ja missä kvanttilaskenta tuo huomattavaa etua.

Nopein suurten kokonaislukujen tekijöihinjakoalgoritmi on yleinen lukukuntaseula (\emph{General Number Field Sieve, GNFS}) (\cite{doi:10.1137/S0036144598347011}). Yleisen lukukuntaseulan asymptoottinen ajoaika on \[\exp  O(c(\log n)^{1/3} (\log \log n)^{2/3}),\] missä $n$ on kokonaisluku, joka halutaan jakaa tekijöihin ja $c$ on vakio. Yleinen lukukuntaseula on siis ajan suhteen eksponentiaalinen algoritmi. Shorin algoritmin asymptoottinen ajoaika kvanttitietokoneella on \[O((\log n)^{2}(\log \log n) (\log \log \log n)),\] missä $n$ on luku, joka halutaan jakaa tekijöihin. Tämän lisäksi tarvitaan kvanttitietokoneella tehdyn laskennan jälkeen $O(\log n)$ verran prosessointia klassisella tietokoneella. Tämä tehdään, jotta kvanttitietokoneen antama tulos eli $n$:n tekijät voidaan muuttaa klassisen tietokoneen ymmärtämään muotoon. Shorin algoritmi toimii siis polynomisessa ajassa.

Toistaiseksi Shorin algoritmia ei ole saatu jakamaan tekijöihin kovin suuria lukuja johtuen laskentaan tarvittavasta suuresta resurssien määrästä (\cite{martin2012experimental}). Martin-Lopez et al. (2012) saivat Shorin algoritmia käyttäen jaettua luvun 21 tekijöihin. Monz et al. (2016) saivat jaettua luvun 15 tekijöihin 99\% toimintavarmuudella käyttäen laskennassaan viittä kubittia, vaikka oletus oli laskennan vaativan 12 kubittia. Lisäksi Monz et al. (2016) saivat kokeessaan Shorin algoritmin skaalautumaan eli pidettyä atomit stabiilissa tilassa, joka mahdollistaisi suurempien lukujen jakamisen tekijöihin. Shorin algoritmin soveltaminen nykypäivänä käytettyihin RSA-salausavaimiin vaatisi miljardeja operaatioita tuhansilla fyysisillä kubiteilla (\cite{bernstein2017post}). Mavroeidis et al. (2018) mukaan 1024-bittisen RSA-salausavaimen tekijöihinjakamiseen tarvitaisiin 2000-kubittinen kvanttitietokone.