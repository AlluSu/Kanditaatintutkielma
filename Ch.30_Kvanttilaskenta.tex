\chapter{Kvanttilaskenta}

\section{Kvanttilaskenta ja kvanttitietokoneet}
Klassisessa eli niin sanotussa tavallisessa tietokoneessa informaatio esitetään bitteinä ja yksi bitti on tiedon perusyksikkö (\cite{doi:10.1080/23742917.2016.1226650}). Yksittäinen bitti voi saada vain yhden diskreetin arvon kerrallaan ja näitä arvoja kuvataan yleensä arvoilla 0 ja 1. Bitti voi siis olla arvoltaan vuorostaan joko 0 tai 1. Klassisessa tietokoneessa näitä bittejä käsitellään loogisten porttien kautta.

Kvanttitietokoneen laskennan perusyksikkö taas on kubitti eli kvanttibitti. Kubitti voi olla bitin tavoin myös kahdessa eri tilassa. Merkitään näitä tiloja symboleilla
$\ket{0}$ ja $\ket{1}$.\footnote{Kvanttimekaniikassa notaatiota $\ket{}$ kutsutaan Diracin notaatioksi. Se on yleinen notaatio kvanttimekaniikassa tarkoittaen tilaa (\cite{nielsen2001quantum}).} Kubitti eroaa tavallisesta bitistä siten, että se voi olla tilojen $\ket{0}$ tai $\ket{1}$ sijaan niin sanotussa superpositiotilassa. Tämä tarkoittaa siis sitä, että mittauksen aikana kubitti voi olla arvoltaan 0 tai 1, mutta laskennan aikana se on yhtäaikaa sekä 0 että 1. Eli tilat $\ket{0}$ ja $\ket{1}$ voivat esiintyä yhtäaikaa. Kvanttitietokoneessa kubitteja käsittelee kvanttiportit kuten klassisessa tietokoneessa bittejä käsittelee loogiset portit.

Esimerkiksi kolmella kubitilla laskentaa tekevä kvanttitietokone mahdollistaa 8 eri tilaa samanaikaisesti. Kolmella bitillä laskentaa tekevä klassinen tietokone mahdollistaa myös 8 eri tilaa, mutta vain yksi näistä kahdeksasta tilasta voi olla kerrallaan voimassa. Kvanttitietokoneen tehokkaamman laskentatehon mahdollistaa siis mahdollisuus suorittaa laskenta samanaikaisesti eli rinnakkain jokaiselle kubitin eri tilalle. Kvanttitietokone tarjoaa siis eksponentiaalisesti nopeamman laskentatehon, joka uhkaa muun muassa julkisen avaimen salausta.

Nykypäivän kvanttitietokoneet ovat vielä kehitysvaiheessa. Ne vaativat suuren ja kalliin infrastruktuurin ympärilleen muun muassa jäähdytystä ja sähkömagneettiselta säteilyltä suojautumista varten. Kuitenkin tilanne oli aikoinaan samanlainen kun klassiset tietokoneet alkoivat ilmaantumaan. Tulevaisuudessa on siis odotettavissa, että kvanttitietokoneiden fyysinen koko ja vaatima infrastruktuuri tulee pienentymään.

\section{Shorin algoritmi}
Kappaleessa kaksi eli nykyisistä salausjärjestelmistä puhuttaessa mainitsimme Shorin algoritmin. Vuonna 1994 Peter Shor esitteli Shorin algoritmin, jolla voidaan jakaa kokonaisluku tekijöihinsä kvanttitietokoneella tehokkaasti eli polynomisessa ajassa (\cite{hayward2008quantum}). Shorin algoritmin toiminta ja tehokkuus perustuu siihen kuinka se hyödyntää kvanttirinnakkaisuutta (\emph{quantum parallelism}). Tämä tarkoittaa siis sitä, että kvanttitietokoneella Shorin algoritmi suorittaa eksponentiaalisen määrän operaatioita yhdessä askeleessa. Klassisella tietokoneella sama laskenta veisi eksponentiaalisen määrän aikaa.

Shor huomasi, että Eulerin kehittämää tekijöihinjakoalgoritmia pystyttiin nopeuttamaan käyttäen kvanttirinnakkaisuutta apuna (\cite{doi:10.1080/23742917.2016.1226650}). Kuvaillaan seuraavaksi Eulerin algoritmin toimintaa (\cite{hayward2008quantum}). Olkoon meillä funktio 
\[F(a) = x^{a} \mod n\] 
joka on jaksollinen kun $x$ on suhteellinen alkuluku\footnote{ks. kappale 2.2.} $n$:n kanssa ja $n$ on nyt luku jonka tahdomme jakaa tekijöihin. Koska $F(a)$ on jaksollinen, niin sillä on tällöin jokin jakso $r$. Shorin algoritmi siis yrittää löytää $r$:n eli funktion $F(a) = x^{a} \mod n$ jakson. Tiedetään, että 
\begin{equation}
    \begin{split}
    & x^{0} \mod n = 1 \; \text{koska} \;  x^0 = 1 \; \text{joten} \\
    & x^{r} \mod n = 1 \; \text{ja} \\
    & x^{2r} \mod n = 1 \\
    & \; \text{ja niin edelleen kun $r$ saa monikertoja.}
    \end{split}
\end{equation}
Siten voidaan johtaa:
\begin{align*}
    x^{r} \equiv 1 \mod n \\
    (x^{r/2})^{2} = x^{r} \equiv 1 \mod n \\
    (x^{r/2})^{2} - 1 \equiv 0 \mod n
\end{align*}
ja jos $r$ on parillinen niin:
\[(x^{r/2} - 1)(x^{r/2} + 1) \equiv 0 \mod n\]
Nyt $(x^{r/2} - 1)(x^{r/2} + 1)$ on $n$:n eli luvun jonka haluamme jakaa tekijöihin monikerta. Joten jos $\lvert x^{r/2} \rvert$ ei ole 1, niin ainakin toisella $(x^{r/2} - 1), (x^{r/2} + 1)$ on sama tekijä kuin $n$:llä. Nyt laskemalla $syt(x^{r/2} - 1, n)$ ja $syt(x^{r/2} + 1, n)$ saadaan $n$:n tekijä\footnote{ks. kappale 2.2}.

Simuloidaan nyt Eulerin algoritmia pienellä syötteellä (\cite{doi:10.1080/23742917.2016.1226650}). Olkoon $n$ = 15 ja haluamme jakaa sen tekijöihin.

\begin{enumerate}
    \item Valitaan suhteellinen alkuluku. Valitaan 11, koska $syt(11,15) = 1$.
    
    \item Ryhdytään laskemaan $x^{a} \equiv 1 \mod n$, missä $a \in \mathbb{N}$.
    
    \begin{enumerate}
    
        \item $11^{1} \equiv 1 \mod 15 = 0$ kokonaista ja jakojäännöksenä 11.
        
        \item $11^{2} \equiv 1 \mod 15 = 121$ eli 8 kokonaista ja jakojäännöksenä 1.
        
        \item $11^{3} \equiv 1 \mod 15 = 1331$ eli 88 kokonaista ja jakojäännöksenä 11.
    \end{enumerate}
    
    \item Jatketaan näin korottamalla $x = 11$ aina korkeampiin potensseihin. Jakojäännös jaettaessa luvulla 15 vaihtelee antaen joko luvun 1 tai 11.
    
    \item Saamme nyt jaksoksi $r = 2$, koska kun lukua 11 jaetaan luvulla 15 saamme aina jakojäännökseksi joko 1 tai 11.
    
    \item Lasketaan nyt $x^{r/2}$, jolloin saadaan $x^{r/2} = 11^{2/2} = 11$.
    
    \item Lasketaan nyt $(x^{r/2}-1)$ ja $(x^{r/2}+1)$, jolloin saadaan $(11^{2/2} - 1) = (11 - 1) = 10$ ja $(11^{2/2} + 1) = (11 + 1) = 12$.
    
    \item Lasketaan $syt(10,15)$ ja $syt(12,15)$, jolloin saadaan $syt(10,15) = 5$ ja $syt(12,15) = 3$ ja huomataan, että 3 ja 5 ovat alkuluvut jotka muodostavat luvun 15.
    
\end{enumerate}

Ongelmana nyt on, että kun $n$ kasvaa hyvin suureksi, niin jakson $r$ selvittäminen funktiolla $F(a)$ käy hyvin hankalaksi. Klassisilla tietokoneilla tämän ratkaisemiseen käytetään apuna nopeita Fourier-muunnoksia (\emph{Fast-Fourier Transform, FFT}), mutta suurilla $n$:n arvoilla niiden laskeminen on hyvin epäkäytännöllistä. Tässä vaiheessa Shorin algoritmi tulee apuun. Shorin algoritmi ratkaisee jakson $r$ etsimisen hyvin tehokkaasti käyttäen apunaan kvanttirinnakkaisuutta. Jakson määrittäminen on ainut kohta algoritmissa, jossa tarvitaan kvanttitietokonetta ja missä kvanttilaskenta tuo huomattavaa etua. Muuten edellä esitelty tekijöihinjakoalgoritmi toimii hyvin klassisella tietokoneella, mutta jakson $r$ määrittäminen on tehokkaampaa käyttäen kvanttitietokonetta ja Shorin algoritmia. 