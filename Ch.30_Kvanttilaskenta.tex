\chapter{Kvanttilaskenta}

\section{Kvanttilaskenta ja kvanttitietokoneet}
Klassisessa eli niin sanotussa tavallisessa tietokoneessa informaatio esitetään bitteinä ja yksi bitti on tiedon perusyksikkö (\cite{doi:10.1080/23742917.2016.1226650}). Yksittäinen bitti voi saada vain yhden diskreetin arvon kerrallaan ja näitä arvoja kuvataan yleensä arvoilla 0 ja 1. Bitti voi siis olla arvoltaan vuorostaan joko 0 tai 1. Klassisessa tietokoneessa näitä bittejä käsitellään loogisten porttien kautta.

Kvanttitietokoneen laskennan perusyksikkö taas on kubitti eli kvanttibitti. Kubitti voi olla bitin tavoin myös kahdessa eri tilassa. Merkitään näitä tiloja symboleilla
$\ket{0}$ ja $\ket{1}$.\footnote{Kvanttimekaniikassa notaatiota $\ket{}$ kutsutaan Diracin notaatioksi. Se on yleinen notaatio kvanttimekaniikassa tarkoittaen tilaa (\cite{nielsen2001quantum}).} Kubitti eroaa tavallisesta bitistä siten, että se voi olla tilojen $\ket{0}$ tai $\ket{1}$ sijaan niin sanotussa superpositiotilassa. Tämä tarkoittaa siis sitä, että mittauksen aikana kubitti voi olla arvoltaan 0 tai 1, mutta laskennan aikana se on yhtäaikaa sekä 0 että 1. Eli tilat $\ket{0}$ ja $\ket{1}$ voivat esiintyä yhtäaikaa. Kvanttitietokoneessa kubitteja käsittelee kvanttiportit kuten klassisessa tietokoneessa bittejä käsittelee loogiset portit.

Esimerkiksi kolmella kubitilla laskentaa tekevä kvanttitietokone mahdollistaa 8 eri tilaa samanaikaisesti. Kolmella bitillä laskentaa tekevä klassinen tietokone mahdollistaa myös 8 eri tilaa, mutta vain yksi näistä kahdeksasta tilasta voi olla kerrallaan voimassa. Kvanttitietokoneen tehokkaamman laskentatehon mahdollistaa siis mahdollisuus suorittaa laskenta samanaikaisesti eli rinnakkain jokaiselle kubitin eri tilalle. Kvanttitietokone tarjoaa siis eksponentiaalisesti nopeamman laskentatehon, joka uhkaa muun muassa julkisen avaimen salausta.

Nykypäivän kvanttitietokoneet ovat vielä kehitysvaiheessa. Ne vaativat suuren ja kalliin infrastruktuurin ympärilleen muun muassa jäähdytystä ja sähkömagneettiselta säteilyltä suojautumista varten. Kuitenkin tilanne oli aikoinaan samanlainen kun klassiset tietokoneet alkoivat ilmaantumaan. Tulevaisuudessa on siis odotettavissa, että kvanttitietokoneiden fyysinen koko ja vaatima infrastruktuuri tulee pienentymään.

\section{Shorin algoritmi}
Kappaleessa 2 nykyisistä salausjärjestelmistä puhuttaessa mainitsimme Shorin algoritmin. Vuonna 1994 Peter Shor esitteli Shorin algoritmin, jolla voidaan jakaa kokonaisluku tekijöihinsä kvanttitietokoneella tehokkaasti eli polynomisessa ajassa (\cite{hayward2008quantum}). Shorin algoritmin toiminta ja tehokkuus perustuu siihen kuinka se hyödyntää kvanttirinnakkaisuutta (\emph{quantum parallelism}). Tämä tarkoittaa siis sitä, että kvanttitietokoneella Shorin algoritmi suorittaa eksponentiaalisen määrän operaatioita yhdessä askeleessa. Klassisella tietokoneella sama laskenta veisi eksponentiaalisen määrän aikaa.

Shor huomasi, että Eukleideen kehittämää tekijöihinjakoalgoritmia pystyttiin nopeuttamaan käyttäen kvanttirinnakkaisuutta apuna (\cite{doi:10.1080/23742917.2016.1226650}). Kuvaillaan seuraavaksi Eukleideen algoritmin toimintaa (\cite{hayward2008quantum}). Olkoon meillä funktio
\begin{equation}
    \label{eq1}
    F(a) = x^{a} \mod n
\end{equation}

joka on jaksollinen kun $x$ on suhteellinen alkuluku\footnote{ks. kappale 2.2.} $n$:n kanssa ja $n$ on nyt luku jonka tahdomme jakaa tekijöihin. Koska $F(a)$ on jaksollinen (MÄÄRITTELE TÄMÄ JAKSO), niin sillä on tällöin jokin jakso $r$. Shorin algoritmi siis yrittää löytää $r$:n eli funktion $F(a) = x^{a} \mod n$ jakson. Tiedetään, että 
\begin{equation}
    \label{eq2}
    \begin{split}
    & x^{0} \mod n = 1 \; \text{koska} \;  x^0 = 1 \; \text{joten} \\
    & x^{r} \mod n = 1 \; \text{ja} \\
    & x^{2r} \mod n = 1 \\
    & \; \text{ja niin edelleen kun $r$ saa monikertoja.}
    \end{split}
\end{equation}
Siten voidaan johtaa
\begin{equation}
    \label{eq3}
    \begin{split}
    x^{r} & \equiv 1 \mod n \\
    (x^{r/2})^{2} = x^{r} & \equiv 1 \mod n \\
    (x^{r/2})^{2} - 1 & \equiv 0 \mod n
    \end{split}
\end{equation}
ja jos $r$ on parillinen niin
\begin{equation}
    \label{eq4}
    (x^{r/2} - 1)(x^{r/2} + 1) \equiv 0 \mod n
\end{equation}

Nyt $(x^{r/2} - 1)(x^{r/2} + 1)$ on $n$:n eli luvun jonka haluamme jakaa tekijöihin monikerta. Joten jos $\lvert x^{r/2} \rvert$ ei ole 1, niin ainakin toisella $(x^{r/2} - 1), (x^{r/2} + 1)$ on sama tekijä kuin $n$:llä. Nyt laskemalla $syt(x^{r/2} - 1, n)$ ja $syt(x^{r/2} + 1, n)$ saadaan $n$:n tekijä\footnote{ks. kappale 2.2}.

Simuloidaan nyt Eulerin algoritmia pienellä syötteellä (\cite{doi:10.1080/23742917.2016.1226650}). Olkoon $n$ = 15 ja haluamme jakaa sen tekijöihin.

\begin{enumerate}
    \item Valitaan suhteellinen alkuluku. Valitaan 11, koska $syt(11,15) = 1$.
    
    \item Ryhdytään laskemaan $x^{a} \equiv 1 \mod n$, missä $a \in \mathbb{N}$.
    
    \begin{enumerate}
    
        \item $11^{1} \equiv 1 \mod 15 = 0$ kokonaista ja jakojäännöksenä 11.
        
        \item $11^{2} \equiv 1 \mod 15 = 121$ eli 8 kokonaista ja jakojäännöksenä 1.
        
        \item $11^{3} \equiv 1 \mod 15 = 1331$ eli 88 kokonaista ja jakojäännöksenä 11.
    \end{enumerate}
    
    \item Jatketaan näin korottamalla $x = 11$ aina korkeampiin potensseihin. Jakojäännös jaettaessa luvulla 15 vaihtelee antaen joko luvun 1 tai 11.
    
    \item Saamme nyt jaksoksi $r = 2$, koska kun lukua 11 jaetaan luvulla 15 saamme aina jakojäännökseksi joko 1 tai 11.
    
    \item Lasketaan nyt $x^{r/2}$, jolloin saadaan $x^{r/2} = 11^{2/2} = 11$.
    
    \item Lasketaan nyt $(x^{r/2}-1)$ ja $(x^{r/2}+1)$, jolloin saadaan $(11^{2/2} - 1) = (11 - 1) = 10$ ja $(11^{2/2} + 1) = (11 + 1) = 12$.
    
    \item Lasketaan $syt(10,15)$ ja $syt(12,15)$, jolloin saadaan $syt(10,15) = 5$ ja $syt(12,15) = 3$ ja huomataan, että 3 ja 5 ovat alkuluvut jotka muodostavat luvun 15.
    
\end{enumerate}

Ongelmana nyt on, että kun $n$ kasvaa hyvin suureksi, niin jakson $r$ selvittäminen funktiolla $F(a)$ käy hyvin hankalaksi. Klassisilla tietokoneilla tämän ratkaisemiseen käytetään apuna nopeita Fourier-muunnoksia (\emph{Fast-Fourier Transform, FFT}), mutta suurilla $n$:n arvoilla niiden laskeminen on hyvin epäkäytännöllistä. Shorin algoritmi ratkaisee jakson $r$ etsimisen tehokkaasti käyttäen apunaan kvanttirinnakkaisuutta. Jakson määrittäminen on ainut kohta algoritmissa, jossa tarvitaan kvanttitietokonetta ja missä kvanttilaskenta tuo huomattavaa etua.

Nopein suurten kokonaislukujen tekijöihinjako algoritmi on yleinen lukukuntaseula (\emph{General Number Field Sieve, GNFS}) (\cite{doi:10.1137/S0036144598347011}). \emph{GNFS}:n asymptoottinen ajoaika on $exp(c(\log n)^{1/3} (\log \log n)^{2/3})$, missä $n$ on kokonaisluku, joka halutaan jakaa tekijöihin ja $c$ on vakio. GNFS on siis eksponentiaalinen algoritmi. Shorin algoritmin asymptoottinen ajoaika kvanttitietokoneella on $O((\log n)^{2}(\log \log n) (\log \log \log n))$, missä $n$ on luku joka halutaan jakaa tekijöihin. Tämän lisäksi tarvitaan kvanttitietokoneella tehdyn laskennan jälkeen $O(\log n)$ verran prosessointia klassisella tietokoneella. Tämä tehdään, jotta kvanttitietokoneen antama tulos eli $n$:n tekijät voidaan muuttaa klassisen tietokoneen ymmärtämään muotoon.