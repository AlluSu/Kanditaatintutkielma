\chapter{Kvanttilaskenta}
Seuraavaksi käsittelemme kvanttilaskentaa ja sitä hyödyntäviä kvanttitietokoneita. Lisäksi tutustumme Shorin algoritmiin ja kuinka se jakaa suuret kokonaisluvut tehokkaasti tekijöihinsä.

\section{Kvanttilaskenta ja kvanttitietokoneet}
Klassisessa tietokoneessa informaatio esitetään bitteinä ja yksi bitti on tiedon perusyksikkö (\cite{doi:10.1080/23742917.2016.1226650}). Yksittäinen bitti voi saada vain yhden diskreetin arvon kerrallaan ja näitä arvoja kuvataan yleensä arvoilla 0 ja 1. Bitti voi siis olla arvoltaan vuorostaan joko 0 tai 1. Klassisessa tietokoneessa näitä bittejä käsitellään loogisten porttien kautta.

Kvanttitietokoneen laskennan perusyksikkö taas on kubitti eli kvanttibitti (\cite{doi:10.1080/23742917.2016.1226650}). Kvanttitietokoneessa kubitteja käsitellään kvanttiporttien kautta. Kubitti voi olla bitin tavoin myös kahdessa eri tilassa. Merkitään näitä tiloja symboleilla
$\ket{0}$ ja $\ket{1}$.\footnote{Kvanttimekaniikassa notaatiota $\ket{}$ kutsutaan Diracin notaatioksi. Se on yleinen notaatio kvanttimekaniikassa tarkoittaen tilaa (\cite{nielsen2001quantum}).} Kubitti eroaa tavallisesta bitistä siten, että se voi olla tilojen $\ket{0}$ tai $\ket{1}$ sijaan superpositiotilassa. Tämä tarkoittaa siis sitä, että mittauksen aikana kubitti voi olla arvoltaan 0 tai 1, mutta laskennan aikana se on yhtä aikaa sekä 0 että 1. Eli tilat $\ket{0}$ ja $\ket{1}$ voivat esiintyä yhtä aikaa. Superpositiotilassa olevalle kubitille tehty operaatio vaikuttaa kumpaankin arvoon samanaikaisesti (\cite{mavroeidis2018impact}). Kubitit voivat myös lomittua keskenään, jota kutsutaan kvanttilomittumiseksi (\emph{Quantum entanglement}). Kun kaksi kubittia lomittuvat keskenään, sen jälkeen niiden tiloja ei voi enää kuvailla riippumatta toisistaan. Sen sijaan ne kuvataan yhtenä objektina, jolla on neljä erillistä tilaa.

Kvanttitietokoneen tehokkaamman laskentatehon mahdollistaa siis nämä edellä mainitut kvanttimekaniikan ilmiöt, kvanttisuperpositio ja kvanttilomittuminen (\cite{mavroeidis2018impact}). Kvanttitietokoneella on siis mahdollista suorittaa laskentaa samanaikaisesti eli rinnakkain jokaiselle kubitin eri tilalle (\cite{doi:10.1080/23742917.2016.1226650}). Tätä kutsutaan kvanttirinnakkaisuudeksi (\emph{Quantum parallelism}). Kvanttitietokone joka käyttää laskentaan $n$ kubittia mahdollistaa samanaikaisesti $2^{n}$ rinnakkaisesti suoritettavaa operaatiota (\cite{mavroeidis2018impact}). Esimerkiksi kolmella kubitilla laskentaa tekevä kvanttitietokone mahdollistaa 8 eri tilaa samanaikaisesti (\cite{doi:10.1080/23742917.2016.1226650}). Kolmella bitillä laskentaa tekevä klassinen tietokone mahdollistaa myös 8 eri tilaa, mutta vain yksi näistä kahdeksasta tilasta voi olla kerrallaan voimassa.  Kvanttitietokone tarjoaa siis eksponentiaalisesti nopeamman laskentatehon. Tätä eksponentiaalista laskentatehoa hyödyntävät algoritmit uhkaavat muun muassa julkisen avaimen salausta.

Täytyy kuitenkin huomata, että kvanttitietokoneet ovat ylivoimaisia klassisiin tietokoneisiin verrattuna vasta silloin kun ongelmaan voidaan soveltaa algoritmia, joka osaa hyödyntää kvanttitietokoneiden mahdollistamaa kvanttirinnakkaisuutta (\cite{mavroeidis2018impact}). Esimerkiksi kertolaskujen laskemisessa kvanttitietokone ei juuri tuo huomattavaa etua verrattuna klassisiin tietokoneisiin.

Nykypäivän kvanttitietokoneet ovat vielä kehitysvaiheessa (\cite{doi:10.1080/23742917.2016.1226650}). Ne vaativat suuren ja kalliin infrastruktuurin ympärilleen muun muassa jäähdytystä ja sähkömagneettiselta säteilyltä suojautumista varten. Kuitenkin tilanne oli aikoinaan samanlainen kun klassiset tietokoneet alkoivat ilmaantumaan. Tulevaisuudessa on siis odotettavissa, että kvanttitietokoneiden fyysinen koko ja vaatima infrastruktuuri tulee pienentymään.

\section{Shorin algoritmi}
Vuonna 1994 Peter Shor esitteli Shorin algoritmin, jolla julkisen avaimen salaukseen liittyvät matemaattiset ongelmat, diskreetin logaritmin laskeminen ja suurten kokonaislukujen tekijöihinjako, voidaan ratkaista tehokkaasti eli polynomisessa ajassa (\cite{doi:10.1137/S0036144598347011}). Käsittelemme tässä kappaleessa ainoastaan kuinka Shorin algoritmi jakaa suuria kokonaislukuja tekijöihinsä, diskreetin logaritmin laskemista Shorin algoritmin avulla ei käsitellä.

Shorin algoritmin tehokkuus perustuu siihen kuinka se hyödyntää edellä mainittua kvanttirinnakkaisuutta. Kvanttitietokoneella Shorin algoritmi suorittaa eksponentiaalisen määrän operaatioita yhdessä askeleessa mikä taas vaatisi klassisella tietokoneella eksponentiaalisen määrän aikaa.



\iffalse
Shorin algoritmi nojautuu lukuteoriaan (\cite{hayward2008quantum}). Olkoon meillä funktio \[F(a) = x^{a} \mod n\]
joka on jaksollinen\footnote{Jaksollinen funktio tarkoittaa funktiota, joka toistuu samanlaisena tietyn jakson välein.} kun $x$ on suhteellinen alkuluku\footnote{ks. kappale 2.2.} $n$:n kanssa ja $n$ on nyt luku jonka haluamme jakaa tekijöihin. Koska $F(a)$ on jaksollinen niin sillä on tällöin jokin jakso $r$. 
\fi

\iffalse
Shorin algoritmi nojautuu lukuteoriaan (\cite{hayward2008quantum}). %viite
Olkoon meillä funktio
\begin{equation}
    \label{eq1}
    F(a) = x^{a} \mod n
\end{equation}
joka on jaksollinen kun $x$ on suhteellinen alkuluku\footnote{ks. kappale 2.2.} $n$:n kanssa ja $n$ on nyt luku jonka tahdomme jakaa tekijöihin. Koska $F(a)$ on jaksollinen funktio\footnote{Jaksollinen funktio tarkoittaa siis funktiota, joka toistuu samanlaisena tietyn jakson välein.}, niin sillä on tällöin jokin jakso $r$. Shorin algoritmi siis yrittää löytää $r$:n eli funktion $F(a) = x^{a} \mod n$ jakson. Tiedetään, että 
\begin{equation}
    \label{eq2}
    \begin{split}
    & x^{0} \mod n = 1 \; \text{koska} \;  x^0 = 1 \; \text{joten} \\
    & x^{r} \mod n = 1 \; \text{ja} \\
    & x^{2r} \mod n = 1 \\
    & \; \text{ja niin edelleen kun $r$ saa monikertoja.}
    \end{split}
\end{equation}
Siten voidaan johtaa
\begin{equation}
    \label{eq3}
    \begin{split}
    x^{r} & \equiv 1 \mod n \\
    (x^{r/2})^{2} = x^{r} & \equiv 1 \mod n \\
    (x^{r/2})^{2} - 1 & \equiv 0 \mod n
    \end{split}
\end{equation}
ja jos $r$ on parillinen niin
\begin{equation}
    \label{eq4}
    (x^{r/2} - 1)(x^{r/2} + 1) \equiv 0 \mod n
\end{equation}

Nyt $(x^{r/2} - 1)(x^{r/2} + 1)$ on $n$:n eli luvun jonka haluamme jakaa tekijöihin monikerta (\cite{hayward2008quantum}). Joten jos $\lvert x^{r/2} \rvert$ ei ole 1, niin ainakin toisella $(x^{r/2} - 1), (x^{r/2} + 1)$ on sama tekijä kuin $n$:llä. Nyt laskemalla $syt(x^{r/2} - 1, n)$ ja $syt(x^{r/2} + 1, n)$ saadaan $n$:n tekijä\footnote{ks. kappale 2.2}.

Simuloidaan nyt Eukleideen algoritmia siten että $n$ = 15 ja haluamme jakaa luvun $n$ tekijöihin.
\begin{enumerate}
    \item Valitaan suhteellinen alkuluku. Valitaan 11, koska $syt(11,15) = 1$.
    
    \item Ryhdytään laskemaan $x^{a} \equiv 1 \mod n$, missä $a \in \mathbb{N}$.
    
    \begin{enumerate}
    
        \item $11^{1} \equiv 1 \mod 15 = 0$ kokonaista ja jakojäännöksenä 11.
        
        \item $11^{2} \equiv 1 \mod 15 = 121$ eli 8 kokonaista ja jakojäännöksenä 1.
        
        \item $11^{3} \equiv 1 \mod 15 = 1331$ eli 88 kokonaista ja jakojäännöksenä 11.
    \end{enumerate}
    
    \item Jatketaan näin korottamalla $x = 11$ aina korkeampiin potensseihin. Jakojäännös jaettaessa luvulla 15 vaihtelee antaen joko luvun 1 tai 11.
    
    \item Saamme nyt jaksoksi $r = 2$, koska kun lukua 11 jaetaan luvulla 15 saamme aina jakojäännökseksi joko 1 tai 11.
    
    \item Lasketaan nyt $x^{r/2}$, jolloin saadaan $x^{r/2} = 11^{2/2} = 11$.
    
    \item Lasketaan nyt $(x^{r/2}-1)$ ja $(x^{r/2}+1)$, jolloin saadaan $(11^{2/2} - 1) = (11 - 1) = 10$ ja $(11^{2/2} + 1) = (11 + 1) = 12$.
    
    \item Lasketaan $syt(10,15)$ ja $syt(12,15)$, jolloin saadaan $syt(10,15) = 5$ ja $syt(12,15) = 3$ ja huomataan, että 3 ja 5 ovat alkuluvut jotka muodostavat luvun 15.
    
\end{enumerate}
\fi

\iffalse
Algoritmi jolla Shorin algoritmi jakaa luvun $n$ on seuraavanlainen (\cite{doi:10.1080/23742917.2016.1226650}):
\begin{enumerate}

    \item Valitaan satunnainen luku väliltä $x \in \{2, \ldots, n-1\}$
    
    \item Tutkitaan ovatko $x$ ja $n$ suhteellisia alkulukuja\footnote{ks. kappale 2.3} keskenään eli jos $syt(x,n) = 1$, mennään kohtaan 3. Muuten olemme löytäneet toisen tekijöistä.
    
    \item Etsitään funktion $f(x) = x^{a} \mod n$ jakso $r$, missä $a = \mathbb{N}$. Jakson $r$ löytäminen toimii siten, että yhtälöä $f(x) = x^{a} \mod n$ kokeillaan kasvavilla $a$:n arvoilla kunnes löydetään $a$:n arvo jolla yhtälön ratkaisut alkavat toistua.
    
    \item Jos jakso $r$ oli parillinen, niin jatketaan eteenpäin kohtaan 4. Muuten palataan kohtaan 1. ja valitaan uusi satunnainen luku.
    
    \item Lasketaan \[d = max \{syt(x^{r/2}-1,n), syt(x^{r/2}+1,n) \} \]
    
    \item Jos $d \neq 1$, olemme löytäneet tekijän jomman kumman tekijän. Muuten palataan kohtaan 1.
\end{enumerate}
\fi

Ongelmana nyt on, että kun $n$ kasvaa hyvin suureksi, niin jakson $r$ selvittäminen funktiolla $F(a)$ käy hyvin hankalaksi (\cite{doi:10.1080/23742917.2016.1226650}). Klassisilla tietokoneilla tämän ratkaisemiseen käytetään nopeita Fourier-muunnoksia (\emph{Fast-Fourier Transform, FFT}), mutta suurilla $n$:n arvoilla niiden laskeminen on hyvin epäkäytännöllistä. Kuten aiemmin mainittiin Shorin algoritmi ratkaisee jakson $r$ etsimisen tehokkaasti hyödyntäen laskennassaan kvanttirinnakkaisuutta. Jakson $r$ määrittäminen on ainut kohta algoritmissa, jossa tarvitaan kvanttitietokonetta ja missä kvanttilaskenta tuo huomattavaa etua.

Nopein suurten kokonaislukujen tekijöihinjakoalgoritmi on yleinen lukukuntaseula (\emph{General Number Field Sieve, GNFS}) (\cite{doi:10.1137/S0036144598347011}). \emph{GNFS}:n asymptoottinen ajoaika on \[exp(c(\log n)^{1/3} (\log \log n)^{2/3})\] missä $n$ on kokonaisluku, joka halutaan jakaa tekijöihin ja $c$ on vakio. GNFS on siis ajan suhteen eksponentiaalinen algoritmi. Shorin algoritmin asymptoottinen ajoaika kvanttitietokoneella on \[O((\log n)^{2}(\log \log n) (\log \log \log n))\] missä $n$ on luku, joka halutaan jakaa tekijöihin. Tämän lisäksi tarvitaan kvanttitietokoneella tehdyn laskennan jälkeen $O(\log n)$ verran prosessointia klassisella tietokoneella. Tämä tehdään, jotta kvanttitietokoneen antama tulos eli $n$:n tekijät voidaan muuttaa klassisen tietokoneen ymmärtämään muotoon. Shorin algoritmi toimii siis polynomisessa ajassa.

%ehkä turha?? yhteenvetoon?
Toistaiseksi Shorin algoritmia ei ole saatu jakamaan tekijöihin kovin suuria lukuja johtuen laskentaan tarvittavasta suuresta resurssien määrästä (\cite{martin2012experimental}). Martin-Lopez et al. (2012) saivat Shorin algoritmia käyttäen jaettua luvun 21 tekijöihin. Monz et al. (2016) saivat jaettua luvun 15 tekijöihin 99\% todennäköisyydellä käyttäen laskennassaan viittä kubittia vaikka oletus oli laskennan vaativan 12 kubittia. Lisäksi Monz et al. (2016) saivat kokeessaan Shorin algoritmin skaalautumaan eli pidettyä atomit stabiilissa tilassa, joka mahdollistaisi suurempien lukujen jakamisen tekijöihin. Shorin algoritmin soveltaminen nykypäivänä käytettyihin RSA:n julkisiin avaimiin vaatisi miljardeja operaatioita tuhansilla fyysisillä kubiteilla (\cite{bernstein2017post}). Mavroeidis et al. (2018) mukaan 1024-bittisen RSA-avaimen tekijöihinjakamiseen tarvitaisiin 2000-kubittinen kvanttitietokone.