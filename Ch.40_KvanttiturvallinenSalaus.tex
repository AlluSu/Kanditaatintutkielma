\chapter{Kvanttiturvallinen salaus\label{results}}
Seuraavaksi tutustumme muutamiin kvanttiturvallisiin salausmenetelmiin. Nämä salausmenetelmät ovat koodipohjainen, hilapohjainen ja monimuuttujapohjainen. Edellä mainittujen lisäksi on olemassa lähteistä riippuen muitakin salausmenetelmiä, mutta emme kuitenkaan tämän tutkielman laajuuden puitteissa perehdy aivan kaikkiin. Emme esimerkiksi käsittele elliptisiin käyriin perustuvia kvanttiturvallisia salausmenetelmiä (\emph{isogeny-based cryptography\footnote{Joissain lähteissä \emph{supersingular elliptic curve isogeny cryptography}}}) emmekä tiivistepohjaista salausta (\emph{hash-based cryptography}).

Käsittelemme kvanttiturvallisista salausmenetelmistä niiden idean sekä yleisiä ominaisuuksia muun muassa suorituskyvyssä ja julkisen avaimen koossa. Näitä eri kvanttiturvallisia salausmenetelmiä käyttäviä julkisen avaimen salausjärjestelmiä on implementoitu useita erilaisia variantteja. Näiden eri varianttien välillä on eroja esimerkiksi suorituskyvyssä ja julkisen avaimen koossa. Kuitenkin kaikkien niiden toiminta pohjautuu tässä esitellyihin ideoihin. Jatkossa kvanttiturvallisista salausmenetelmistä puhuttaessa tarkoitetaan kvanttiturvallisia julkisen avaimen salausjärjestelmiä.

Tällä hetkellä tutkitaan ja kehitetään useita eri kvanttiturvallisia salausjärjestelmiä. \emph{National Institute of Standards and Technology (NIST)} ylläpitää prosessia, jossa etsitään kvanttiturvallisia julkisen avaimen salausjärjestelmiä, joista tulisi uusi kvanttiturvallinen standardi (\cite{alagic2020status}).

\section{Koodipohjainen salaus}
Koodipohjainen salaus (\emph{code-based cryptography}) on kvanttiturvallinen salauksen muoto, joka perustuu koodausteoriaan (\emph{coding theory}) (\cite{repka2014overview}). Robert McEliece esitteli vuonna 1978 nimeään kantavan koodipohjaisen julkisen avaimen salausjärjestelmän nimeltään \emph{McEliece Cryptosystem} (lyhyemmin MECS). MECS on ensimmäinen esitelty koodipohjainen salausjärjestelmä. MECS on saanut viime vuosina enemmän huomiota kun kvanttiturvallisesta salauksesta on tullut ajankohtaisempaa. Jatkossa puhuttaessa koodipohjaisesta salauksesta tarkoitamme MECS:iä ja sen variantteja. Käsittelemme tässä tutkielmassa vain MECS:in kvanttiturvallisuutta ja ominaisuuksia.

KIRJOTIA PAREMPI MECS:issä salattava viesti voidaan kuvata muodossa $mG+e$, missä $m$ on $k$-bittiä pitkä merkkijono, $G$ on $k \times n$ matriisi, joka toimii julkisena avaimena ja $e$ on $n$-bittiä pitkä merkkijono, jossa $w$ kappaletta bittejä on 1 (\cite{bernstein2017post}). $G$:tä eli julkista avainta kutsutaan kehitinmatriisiksi (\emph{Generator matrix}). MECS:issä viestin salaus tapahtuu siis siten, että salattavaan viestiin lisätään tahallisesti virheitä.

MECS:in kvanttiturvallisuus perustuu kahteen asiaan (\cite{8012331}). Salatun koodin purkaminen on NP-täydellinen ongelma. Tätä kutsutaan nimellä \emph{Generic decoding problem}. Lisäksi julkisen avaimen eli kehitinmatriisin erottaminen jostakin satunnaisesta avaimesta on myos hankalaa.

Koodipohjainen salaus on laskennallisesti tehokasta, sillä salaaminen ja purkaminen ovat nopeita ja yksinkertaisia operaatioita (\cite{overbeck2009code}). Lisäksi salausjärjestelmä on kestänyt aikaa ja tarkastelua yli 40 vuotta (\cite{8012331}) ja toistaiseksi ei ole löydetty vakavia hyökkäyksiä, jotka uhkaisivat koodipohjaista salausta edes kvanttitietokoneilla (\cite{overbeck2009code}).

Koodipohjainen salaus ei sovellu digitaalisten allekirjoitusten tekemiseen käytännössä (\cite{8012331}). Lisäksi koodipohjainen salausjärjestelmä tuottaa kooltaan hyvin suuria julkisia avaimia jos käytetään kvanttiturvallisia parametreja. Tällöin avaimen koko voi olla väliltä 100 kilotavua aina useisiin megatavuihin (\cite{mavroeidis2018impact}). Tämä voi rajoittaa koodipohjaisen salausjärjestelmän käyttöä joissain sovelluksissa ja  järjestelmissä (\cite{8012331}). Lisäksi aiemmin mainittu kvanttiturvallisuuteen liittyvä ongelma liittyen julkisen avaimen erottamiseen satunnaisesta matriisista on hieman avoin ongelma. Ongelma vaatisi lisää tutkimista ja enemmän formaalia todistuspohjaa. MECS on kvanttiturvallinen, koska siinä käytetään binäärisia Goppa-koodeja. Muilla lineaarisilla virheenkorjauskoodeilla kuten esimerkiksi Reed-Solomon koodeilla oletus ei päde ja järjestelmä ei ole turvallinen.

MECS ja sen variantit ovat hyviä kandidaatteja nykyisten salausjärjestelmien korvaajiksi. \emph{Classic McEliece} on eräs koodipohjaiseen salaukseen perustuva kvanttiturvallinen julkisen avaimen salausjärjestelmä, joka perustuu edellä mainittuun MECS salausjärjestelmään. (\cite{alagic2020status}). Classis McEliece on NIST:in standardointiprosessin kolmannen kierroksen finalisteista yksi neljästä kvanttiturvallisesta julkisen avaimen salausjärjestelmästä ja ainut koodipohjaiseen salaukseen perustuva. NIST uskoo, että Classis McEliece olisi valmis standardointia varten kolmannen kierroksen lopussa.

\section{Hilapohjainen salaus}
Hilapohjainen salaus (\emph{lattice-based cryptography}) on kvanttiturvallinen salauksen muoto (\cite{regev2006lattice}). Hilapohjaisessa salauksessa salaus perustuu tiettyihin laskennallisesti vaativiin ongelmiin koskien hiloja. Hila on matemaattinen objekti, joka kuvataan joukkona pisteitä \emph{n}-ulotteisessa avaruudessa ja sillä on jonkinlainen jaksollinen rakenne. Formaalimmin hila on \emph{n}:stä lineaarisesti riippumattomasta vektorista muodostuva joukko vektoreita 
\[L(v_1, \ldots ,v_n) =\Bigg\{ {\sum_{i=1}^{n}\alpha_i 
v_i|\alpha_i \in \mathbb{Z}} \Bigg\},\]
missä vektorit $v_1, \ldots ,v_n$ ovat hilan kanta.

Monissa hiloihin liittyvissä 
laskennallisissa ongelmissa ollaan kiinnostuneita löytämään jokin lyhin vektori tai vektoreita. Lyhimmän vektorin ongelma (\emph{SVP, Shortest Vector Problem)} on yleinen esimerkki laskennallisesta ongelmasta kun puhutaan hiloista. \emph{SVP}:ssä annetaan hilan kanta ja tehtävän on määritellä lyhin vektori hilassa, joka ei ole nollavektori. \emph{SVP}:n haastavuus piilee siinä, että hilalla on monta eri kantaa ja hilan kanta koostuu erittäin pitkistä vektoreista.

Hilapohjaisessa salauksessa huomattavaa on se miten salauksen vahvuus perustuu ongelmien pahimman tapauksen mukaan (\emph{worst-case hardness}). Esimerkiksi nykyisissä salausjärjestelmissä käyettävää suurten alkulukujen tekijöihin jakamisen vaikeutta kuvataan keskimääräisen tapauksen mukaan (\emph{average-case hardness}). Tämä tarkoittaa käytännössä sitä, että alkulukujen tekijöihinjako on helppo laskennallinen ongelma, jos tekijät ovat esimerkiksi pieniä tai parillisia lukuja. Tekijöihinjako taas vaikeutuu, jos luvut ovat hyvin suuria. Tällaista ilmiöitä ei esiinny hilojen kanssa, että olisi jokin tietty jakauma mikä määrittelee onko ongelma laskennallisesti helppo vai vaikea.

Hilapohjaisen salauksen hyviä puolia ovat muun muassa salaukseen tarvittavan laskennan yksinkertaisuus, koska ne vaativat usein vain modulaariartimetiikkaa (\cite{regev2006lattice}). Tämä on eduksi silloin jos resursseja kuten muistia ja laskentatehoa on rajoitetusti kuten esimerkiksi sulautetuissa järjestelmissä.

Huonona puolena hilapohjaisessa salauksessa on se, että salatun viestin koko kasvaa noin 30-kertaiseksi verrattuna alkuperäiseen salaamattomaan viestiin (\cite{8275352}). Esimerkiksi \emph{Ring-LWE} on eräs hilapohjainen julkisen avaimen salausjärjestelmä, joka kasvattaa salatessaan 128-tavuisen salaamattoman viestin 4096-tavuiseksi. Nykyisissä julkisen avaimen salausjärjestelmissä salaamattoman ja salatun viestin koko on täysin sama.

Hiloihin perustuviin ongelmiin ei ole tällä hetkellä tiedossa olevia kvanttialgoritmeja mikä tekee siitä luonnollisesti oivallisen kvanttiturvallisen salausmenetelmän (\cite{regev2006lattice}). NIST:in kvanttiturvallisten julkisen avaimen salausjärjestelmien standardointiprosessissa kolme neljästä kolmannen kierroksen finalistista ovat hilapohjaiseen salaukseen perustuvia (\cite{alagic2020status}). Yksi näistä finalisteista on nimeltään NTRU, joka on osoittautunut tehokkaaksi ja turvalliseksi salausjärjestelmäksi. NTRU:sta povataankin standardointikierroksen finalistia.

\section{Monimuuttujapohjainen salaus}
Monimuuttujapohjainen salaus (\emph{multivariate-based cryptography}) on eräs kvanttiturvallisen salauksen muoto. Monimuuttujapohjaista salausta käytetään monimuuttujapohjaisen julkisen avaimen salausjärjestelmän muodostamiseen (\emph{Multivariate public key cryptosystem}) (\cite{Ding2009}). Monimuuttujapohjainen salaus perustuu monta muuttujaa sisältävien yhtälöryhmien ratkaisun vaikeuteen. Yhtälöryhmien yhtälöt ovat neliöllisiä eli epälineaarisia äärellisessä kunnassa.

Monimuuttujapohjaisessa julkisen avaimen salausjärjestelmässä julkinen avain on yhtälöryhmä neliöllisiä polynomeja, joissa on monta muuttujaa pienessä äärellisessä kunnassa \emph{K} (\cite{8012305}). Esimerkkinä: 
    \begin{align*}
        p^{(1)}(x_{1}...,x_{n}) &= \sum_{i=1}^{n} p_{ij}^{(1)}x_{i}x_ {j}+\sum_{i=1}^{n}p_ {i}^{(1)}x_{i}+p_ {0}^{(1)} \\
        p^{(2)}(x_{1}...,x_{n}) &= \sum_{i=1}^{n} p_{ij}^{(2)}x_{i}x_ {j}+\sum_{i=1}^{n}p_ {i}^{(2)}x_{i}+p_ {0}^{(2)} \\
        \vdots \\
        p^{(m)}(x_{1}...,x_{n}) &= \sum_{i=1}^{n} p_{ij}^{(m)}x_{i}x_ {j}+\sum_{i=1}^{n}p_ {i}^{(m)}x_{i}+p_ {0}^{(m)}
    \end{align*}
Tällaisen julkisen avaimen salausjärjestelmän turvallisuus perustuu niin kutsuttuun \emph{MQ}-ongelmaan (\emph{Multivariate quadratic polynomial problem}).

\emph{MQ}-ongelma: Ratkaise yhtälöryhmä $p_{1}(x) = p_{2}(x) = ... = p_ {m}(x) = 0$, missä jokainen $p_{i}$ on neliöllinen joukossa $x = (x_{1}, ..., x_{n})$ (\cite{Ding2009}).

\emph{MQ}-ongelma on todistettu NP-kovaksi ongelmaksi jokaisessa kunnassa ja sen uskotaan siten olevan vaikea ongelma myös kvanttitietokoneille (\cite{8012305}). Tähän perustuu monimuuttujapohjaisen julkisen avaimen salausjärjestelmän suojaus.

Monimuuttujapohjaisessa salauksessa on paljon hyviä puolia. Monimuuttujapohjaiset salausjärjestelmät voidaan implementoida tehokkaiksi, jolloin ne ovat nopeampia kuin muut kvanttiturvallisest salausjärjestelmät. Monimuuttujapohjaiset salausjärjestelmät vaativat kohtuullisesti laskentatehoa, jolloin sovelluskohteita voi löytyä IoT:n parista. Ne käyttävät ainoastaan aritmeettisia laskuoperaatioita kuten kertolaskua ja yhteenlaskua. Tällöin niitä voi hyödyntää laitteissa, joissa ei ole paljoa resursseja saatavilla, kuten esimerkiksi sirukorteissa ja RFID-teknologiaa käyttävissä siruissa. Lisäksi monimuuttujapohjaiset allekirjoitusmenetelmät luovat pituudeltaan hyvin lyhyitä allekirjoituksia verrattuna esimerkiksi klassisiin tai muihin kvanttiturvallisiin allekirjoituksiin.

Monimuuttujapohjaisissa salausjärjestelmissä huonona puolena on niiden tuottamien avainten suuret koot. Keskimäärin monimuuttujapohjaiset salausjärjestelmät luovat julkisen avaimen, jonka koko on väliltä 10--100 kilotavua. \emph{Rainbow} on yksi NIST:in tutkima ehdokas, josta voisi tulla uusi kvanttiturvallinen standardi allekirjoitusten tekoon. (\cite{alagic2020status}). \emph{Rainbow} on monimuuttujapohjainen allekirjoittamiseen luotu järjestelmä, joka tuottaa julkisen avaimen, joka on kooltaan yli 16 kilotavua (\cite{Ding2009}). Nämä suuret avainten koot saattavat tuottaa ongelmia muun muassa sulautetuissa järjestelmissä tai järjestelmissä, joissa verkkoyhteydet ovat hyvin rajoittuneet ja jossa avaimia pitäisi lähettää monta kertaa verkon yli (\cite{8012305}). Lisäksi monimuuttujapohjaisen salauksen parissa on salausjärjestelmiä, joiden kvanttiturvallisuutta ei ole formaalisti todistettu ja sieltä puuttuu formaalia teoriapohjaa. Kuitenkin käytännössä useat monimuuttujapohjaiset salausjärjestelmät ovat pysyneet turvallisina erilaisia hyökkäyksiä vastaan, vaikka formaali teoriapohja puuttuu.

\section{Kvanttiturvallisten salausjärjestelmien vertailua}
Yhteenveto menetelmistä taulukkomuodossa.
\begin{table}[h]
\caption{Kvanttiturvallisia salausmenetelmiä}
\label{tab:pqc}
\begin{adjustbox}{width=\textwidth}
\begin{tabular}{|l|l|l|l|}
\hline
Menetelmä             & Hyviä puolia                                                                                                                                     & Huonoja puolia                                                                                                                                                          & Esimerkki algoritmi \\ \hline
Koodipohjainen        & \begin{tabular}[c]{@{}l@{}}Laskennallisesti yksinkertainen ja tehokas\\ Kestänyt aikaa ja tarkastelua, jonka takia ymmärretty hyvin\end{tabular} & \begin{tabular}[c]{@{}l@{}}Suuri julkisen avaimen koko\\ Ei sovellu käytännössä allekirjoitusten tekoon\\ Kvanttiturvallisuuden syvempi formaali teoriapohja uupuu\end{tabular} & Classisc McEliece   \\ \hline
Hilapohjainen         & Laskennallisesti yksinkertainen ja tehokas                                                                                                       & Salatun viestin koko kasvaa n. 30-kertaiseksi                                                                                                                           & NTRU                \\ \hline
Monimuuttujapohjainen & \begin{tabular}[c]{@{}l@{}}Laskennallisesti yksinkertainen ja tehokas\\ Lyhyet allekirjoitukset\end{tabular}                                     & \begin{tabular}[c]{@{}l@{}}Suuri julkisen avaimen koko\\ Kvanttiturvallisuuden syvempi formaali teoriapohja uupuu\end{tabular}                                                  & Rainbow             \\ \hline
\end{tabular}
\end{adjustbox}
\end{table}