\chapter{Kvanttiturvallinen salaus\label{results}}
Seuraavaksi tutustumme kvanttiturvallisiin salausmenetelmiin. Esittelemme koodipohjaisen, hilapohjaisen ja monimuuttujapohjaisen salausmenetelmän. Edellä mainittujen lisäksi on olemassa lähteistä riippuen muitakin salausmenetelmiä, mutta emme kuitenkaan tämän tutkielman laajuuden puitteissa perehdy aivan kaikkiin. Emme esimerkiksi käsittele elliptisiin käyriin perustuvia kvanttiturvallisia salausmenetelmiä (\emph{isogeny-based cryptography\footnote{Joissain lähteissä \emph{supersingular elliptic curve isogeny cryptography}}}) emmekä tiivistepohjaista salausta (\emph{hash-based cryptography}).

Käsittelemme kvanttiturvallisista salausmenetelmistä niiden idean sekä yleisiä ominaisuuksia muun muassa suorituskyvyssä ja julkisen avaimen koossa. Näitä eri kvanttiturvallisia salausmenetelmiä käyttäviä julkisen avaimen salausjärjestelmiä on implementoitu useita erilaisia variantteja ja niiden välillä on eroja esimerkiksi suorituskyvyssä ja julkisen avaimen koossa. Kuitenkin kaikkien niiden toiminta pohjautuu tässä esitellyihin ideoihin. Jatkossa kvanttiturvallisista salausmenetelmistä puhuttaessa tarkoitetaan kvanttiturvallisia julkisen avaimen salausjärjestelmiä.

Tällä hetkellä tutkitaan ja kehitetään useita eri kvanttiturvallisia salausjärjestelmiä. National Institute of Standards and Technology (NIST) ylläpitää prosessia, jossa etsitään kvanttiturvallisia julkisen avaimen salausjärjestelmiä, joista tulisi uusi kvanttiturvallinen standardi (\cite{alagic2020status}).

\section{Koodipohjainen salaus}
Koodipohjainen salaus (\emph{code-based cryptography}) on kvanttiturvallinen salauksen muoto, joka perustuu koodausteoriaan (\emph{coding theory}) (\cite{repka2014overview}). Robert McEliece esitteli vuonna 1978 nimeään kantavan koodipohjaisen julkisen avaimen salausjärjestelmän nimeltään McEliecen salausjärjestelmä (\emph{McEliece Cryptosystem}). McEliecen salausjärjestelmä on ensimmäinen esitelty koodipohjainen salausjärjestelmä ja se on saanut viime vuosina enemmän huomiota kun kvanttiturvallisesta salauksesta on tullut ajankohtaisempaa.

Käydään nyt McEliecen salausjärjestelmän toiminta pintapuolisesti läpi syventymättä sen enempää koodausteoriaan. McEliecen salausjärjestelmä käyttää salauksessaan lineaarisia virheenkorjauskoodeja, tarkennettuna binäärisiä Goppa-koodeja (\cite{8012331}). Virheenkorjauskoodit toimivat siten, että esimerkiksi 64 bittiä loogista dataa talletetaan 72 bittiin fyysistä muistia (\cite{overbeck2009code}). Näin saadaan $64 \times 72$ matriisi bittejä, jota voidaan merkitä $G \in \{0, 1\}^{64 \times 72}$. Matriisin $G$ rivit ovat nyt virheenkorjauskoodi. Näin ollen jokin virhe 72 bitin joukossa voidaan luotettavasti korjata ja kahden bitin virhe voidaan havaita. Virheellä tarkoitetaan tässä siis sitä, että bitti muuttuu toiseksi, esimerkiksi ykkösestä nollaksi. McEliecen salausjärjestelmässä julkinen avain on edellä mainittu matriisi $G$, jota kutsutaan kehitinmatriisiksi (\emph{Generator matrix}). Viestin salaaminen toimii nyt siten, että otetaan virheenkorjauskoodien joukosta jokin koodi ja lisätään siihen tahallisesti tietty määrä virheitä. Formaalisti salattu viesti voidaan kuvata muodossa $mG+e$, missä $m$ on $k$-bittiä pitkä merkkijono joka halutaan salata. $G$ on julkinen avain eli edellä mainittu kehitinmatriisi joka on siis jokin $G \in \{0, 1\}^{k \times n}$ matriisi. Lisäksi $e$ on $n$-bittiä pitkä merkkijono, jossa $w$ kappaletta bittejä on arvoltaan 1. Koodipohjainen salaus puretaan siten, että salauksen purkajan täytyy tietää tehokas algoritmi, jolla koodista voi poistaa virheet.

McEliecen salausjärjestelmän kvanttiturvallisuus perustuu kahteen asiaan (\cite{8012331}). Ensinnäkin salatun koodin purkaminen on NP-täydellinen ongelma jos salauksen purkaja ei tiedä tehokasta purkualgoritmia. Tätä ongelmaa kutsutaan nimellä \emph{Generic Decoding Problem, GDP}. Toiseksi julkisen avaimen eli kehitinmatriisin erottaminen jostakin toisesta satunnaisesta matriisista on hankalaa. On huomattava, että McEliecen salausjärjestelmä on kvanttiturvallinen, koska siinä käytetään virheenkorjauskoodina binäärisia Goppa-koodeja. Muilla virheenkorjauskoodeilla oletus ei päde ja järjestelmä ei ole turvallinen.

Hyvinä puolina koodipohjaisesta salauksesta voidaan mainita, että se on laskennallisesti tehokasta sillä salaaminen ja purkaminen ovat nopeita ja yksinkertaisia operaatioita (\cite{overbeck2009code}). Esimerkiksi McEliecen salausjärjestelmä on tehokkaampi kuin nykypäivänä käytetty elliptisiin käyriin perustuva salaus (\emph{Elliptic Curve Cryptography, ECC}) (\cite{bernstein2017post}). Lisäksi salausjärjestelmä on kestänyt aikaa ja tarkastelua yli 40 vuotta (\cite{8012331}) ja toistaiseksi ei ole löydetty vakavia hyökkäyksiä, jotka uhkaisivat koodipohjaista salausta edes kvanttitietokoneilla (\cite{overbeck2009code}). Aikaisemmin mainittua Groverin algoritmia hyödyntämällä on mahdollista nopeuttaa neliöllisesti brute-force hyökkäystä, missä koitetaan arvata salattu viesti (\cite{bernstein2017post}).

Huonoina puolina mainittaakoon, että koodipohjainen salaus ei sovellu digitaalisten allekirjoitusten tekemiseen (\cite{8012331}). Koodipohjaista salausta käyttäviä digitaalisen allekirjoituksen menetelmiä on mahdollista implementoida, mutta ne eivät ole käytännöllisiä sillä allekirjoituksen koko voi olla jopa useita satoja kilotavuja. Lisäksi itse allekirjoittaminen hidasta (\cite{buchmann2016post}). Koodipohjainen salausjärjestelmä tuottaa kooltaan hyvin suuria julkisia avaimia jos käytetään kvanttiturvallisia parametreja (\cite{8012331}). Tällöin avaimen koko voi olla väliltä 100 kilotavua aina useisiin megatavuihin (\cite{mavroeidis2018impact}). Tämä voi rajoittaa koodipohjaisen salausjärjestelmän käyttöä joissain sovelluksissa ja järjestelmissä kuten esimerkiksi sulautetuissa järjestelmissä (\cite{repka2014overview}). Kuitenkin McEliecen salausjärjestelmästä on olemassa variantti, jolla on mahdollista saavuttaa pienempi julkisen avaimen koko (\cite{buchmann2016post}). Lisäksi aiemmin mainittu julkisen avaimen erottaminen satunnaisesta matriisista on avoin ongelma joka vaatisi lisää tutkimista ja enemmän formaalia todistuspohjaa (\cite{8012331}).

McEliecen salausjärjestelmä ja sen variantit ovat hyviä kandidaatteja nykyisten salausjärjestelmien korvaajiksi (\cite{8012331}). \emph{Classic McEliece} on eräs koodipohjaiseen salaukseen perustuva kvanttiturvallinen julkisen avaimen salausjärjestelmä, joka perustuu edellä mainittuun McEliecen salausjärjestelmään. (\cite{alagic2020status}). Classic McEliece on NIST:in standardointiprosessissa tällä hetkellä yksi neljästä finalistista ja ainut koodipohjaiseen salaukseen perustuva. NIST uskoo, että Classic McEliece olisi valmis standardointia varten kolmannen kierroksen lopussa.

\section{Hilapohjainen salaus}
Hilapohjainen salaus (\emph{lattice-based cryptography}) on kvanttiturvallinen salauksen muoto joka perustuu tiettyihin laskennallisesti vaativiin ongelmiin koskien hiloja (\cite{regev2006lattice}). RSA:n keskittyessä alkulukujen kertolaskuun, hilapohjainen salaus keskittyy matriisien kertolaskuun (\cite{mavroeidis2018impact}). Hila on matemaattinen objekti, joka kuvataan joukkona pisteitä \emph{n}-ulotteisessa avaruudessa ja sillä on jonkinlainen jaksollinen rakenne (\cite{regev2006lattice}). Formaalimmin hila on \emph{n}:stä lineaarisesti riippumattomasta vektorista muodostuva joukko vektoreita 
\[L(v_1, \ldots ,v_n) =\Bigg\{ {\sum_{i=1}^{n}\alpha_i 
v_i|\alpha_i \in \mathbb{Z}} \Bigg\},\]
missä vektorit $v_1, \ldots ,v_n$ ovat hilan kanta.

Monissa hiloihin liittyvissä 
laskennallisissa ongelmissa ollaan kiinnostuneita löytämään jokin lyhin vektori tai vektoreita (\cite{regev2006lattice}). Lyhimmän vektorin ongelma (\emph{SVP, Shortest Vector Problem)} on yleinen esimerkki laskennallisesta ongelmasta kun puhutaan hiloista. \emph{SVP}:ssä annetaan hilan kanta ja tehtävän on määritellä lyhin vektori hilassa, joka ei ole nollavektori. \emph{SVP}:n haastavuus piilee siinä, että hilalla on monta eri kantaa ja hilan kanta koostuu erittäin pitkistä vektoreista.

Hilapohjaisessa salauksessa huomattavaa on se miten salauksen vahvuus perustuu ongelmien pahimman tapauksen mukaan (\emph{worst-case hardness}) (\cite{regev2006lattice}). Esimerkiksi nykyisissä salausjärjestelmissä käytettävää suurten kokonaislukujen tekijöihinjaon vaikeutta kuvataan keskimääräisen tapauksen mukaan (\emph{average-case hardness}). Tämä tarkoittaa käytännössä sitä, että kokonaislukujen tekijöihinjako on helppo laskennallinen ongelma, jos tekijät ovat esimerkiksi pieniä tai parillisia lukuja. Tekijöihinjako taas vaikeutuu, jos luvut ovat hyvin suuria. Tällaista ilmiöitä ei esiinny hilojen kanssa, että olisi jokin tietty jakauma mikä määrittelee onko ongelma laskennallisesti helppo vai vaikea.

Hilapohjaisen salauksen hyviä puolia ovat muun muassa salaukseen tarvittavan laskennan yksinkertaisuus, koska ne vaativat usein vain modulaariartimetiikkaa (\cite{regev2006lattice}). Tämä on eduksi silloin jos resursseja kuten muistia ja laskentatehoa on rajoitetusti kuten esimerkiksi sulautetuissa järjestelmissä. Nykyiseen julkisen avaimen salaukseen verrattuna hilapohjainen julkisen avaimen salaus on myös nopeampaa (\cite{8275352}).

Huonona puolena hilapohjaisessa salauksessa on se, että salatun viestin koko kasvaa noin 30-kertaiseksi verrattuna alkuperäiseen salaamattomaan viestiin (\cite{8275352}). Esimerkiksi \emph{Ring-LWE} on eräs hilapohjainen julkisen avaimen salausjärjestelmä, joka kasvattaa salatessaan 128-tavuisen salaamattoman viestin 4096-tavuiseksi. Nykyisissä julkisen avaimen salausjärjestelmissä salaamattoman ja salatun viestin koko on täysin sama.

Hiloihin perustuviin ongelmiin ei ole tällä hetkellä tiedossa olevia kvanttialgoritmeja, jotka olisivat tehokkaampia kuin klassisella tietokoneella suoritettavat mikä tekee siitä hyvän kvanttiturvallisen salausmenetelmän (\cite{regev2006lattice}). NIST:in standardointiprosessissa kolme neljästä finalistista ovat hilapohjaiseen salaukseen perustuvia (\cite{alagic2020status}). Yksi näistä finalisteista on nimeltään \emph{NTRU}, joka on osoittautunut tehokkaaksi ja turvalliseksi salausjärjestelmäksi. Muihin hilapohjaisiin finalisteihin verrattuna \emph{NTRU} vaikuttaa parhaalta vaihtoehdolta.

Tulevaisuuden tutkimustyöhön hilapohjaisen salauksen saralla kuuluu tehokkaampien salausjärjestelmien implementointi, olemassa olevien salausalgoritmien paranteleminen ja salausjärjestelmiin kohdistuvien hyökkäysmallien laatiminen (\cite{8275352}).

\section{Monimuuttujapohjainen salaus}
Monimuuttujapohjainen salaus (\emph{multivariate-based cryptography}) on kvanttiturvallisen salauksen muoto, joka perustuu monta muuttujaa sisältävien yhtälöryhmien ratkaisun vaikeuteen (\cite{Ding2009}). Yhtälöryhmien yhtälöt ovat neliöllisiä eli epälineaarisia äärellisessä kunnassa.

Monimuuttujapohjaisessa julkisen avaimen salausjärjestelmässä julkinen avain on yhtälöryhmä neliöllisiä polynomeja, joissa on monta muuttujaa pienessä äärellisessä kunnassa \emph{K} (\cite{8012305}). Esimerkkinä: 
    \begin{align*}
        p^{(1)}(x_{1}...,x_{n}) &= \sum_{i=1}^{n} p_{ij}^{(1)}x_{i}x_ {j}+\sum_{i=1}^{n}p_ {i}^{(1)}x_{i}+p_ {0}^{(1)} \\
        p^{(2)}(x_{1}...,x_{n}) &= \sum_{i=1}^{n} p_{ij}^{(2)}x_{i}x_ {j}+\sum_{i=1}^{n}p_ {i}^{(2)}x_{i}+p_ {0}^{(2)} \\
        \vdots \\
        p^{(m)}(x_{1}...,x_{n}) &= \sum_{i=1}^{n} p_{ij}^{(m)}x_{i}x_ {j}+\sum_{i=1}^{n}p_ {i}^{(m)}x_{i}+p_ {0}^{(m)}
    \end{align*}
Monimuuttujapohjaisten julkisen avaimen salausjärjestelmien kvanttiturvallisuus perustuu \emph{MQ}-ongelmaan (\emph{Multivariate quadratic polynomial problem}).

\emph{MQ}-ongelma: Ratkaise yhtälöryhmä \[p_{1}(x) = p_{2}(x) = \ldots = p_ {m}(x) = 0,\] missä jokainen $p_{i}$ on neliöllinen joukossa $x = (x_{1}, \ldots, x_{n})$ (\cite{Ding2009}).

\emph{MQ}-ongelma on todistettu NP-kovaksi ongelmaksi jokaisessa kunnassa ja sen uskotaan siten olevan vaikea ongelma myös kvanttitietokoneille (\cite{8012305}).

Monimuuttujapohjaisen salauksen hyviä puolia on, että monimuuttujapohjaiset salausjärjestelmät ovat laskennallisesti tehokkaita ja nopeampia kuin muut kvanttiturvalliset salausjärjestelmät  (\cite{8012305}). Monimuuttujapohjaiset salausjärjestelmät vaativat vain vähän laskentatehoa sillä ne käyttävät laskennassaan ainoastaan aritmeettisia laskuoperaatioita kuten kertolaskua ja yhteenlaskua. Tällöin niitä voi hyödyntää laitteissa, joissa ei ole paljoa resursseja saatavilla kuten esimerkiksi sirukorteissa, RFID-teknologiaa käyttävissä siruissa ja IoT-laitteissa. Lisäksi monimuuttujapohjaiset digitaaliset allekirjoitusmenetelmät luovat pituudeltaan hyvin lyhyitä allekirjoituksia verrattuna esimerkiksi klassisiin allekirjoituksiin.

Monimuuttujapohjaisissa salausjärjestelmissä huonona puolena on niiden tuottamien avainten suuret koot (\cite{8012305}). Keskimäärin monimuuttujapohjaiset salausjärjestelmät luovat julkisen avaimen, jonka koko on väliltä 10--100 kilotavua. Esimerkiksi \emph{Rainbow}, joka on monimuuttujapohjainen allekirjoittamiseen luotu järjestelmä, tuottaa julkisen avaimen, joka on kooltaan yli 16 kilotavua (\cite{Ding2009}). Tämä tuottaa ongelmia muun muassa sulautetuissa järjestelmissä (\cite{8012305}) ja järjestelmissä, jossa verkkoyhteydet ovat rajoittuneet ja missä avaimia pitäisi lähettää monta kertaa verkon yli esimerkiksi autentikaatiota varten (\cite{Ding2009}). Lisäksi monimuuttujapohjaisen salauksen parissa on salausjärjestelmiä, joiden kvanttiturvallisuutta ei ole formaalisti todistettu ja sieltä puuttuu formaalia teoriapohjaa. Kuitenkin käytännössä useat monimuuttujapohjaiset salausjärjestelmät ovat pysyneet turvallisina erilaisia hyökkäyksiä vastaan, vaikka formaali teoriapohja puuttuu. Edellä mainittu \emph{Rainbow} on NIST:in standardointikierroksella eräs kolmesta finaalin allekirjoittamismenetelmästä ja ainut monimuuttujapohjainen (\cite{alagic2020status}).

Tulevaisuudessa odotetaan, että monimuuttujapohjaisten julkisen avaimen salausjärjestelmien tutkiminen siirtyy uudelle tasolla seuraavan vuosikymmenen aikana (\cite{Ding2009}). Käytännön sovelluksien kannalta kriittisimmät ongelmat ovat julkisen avaimen koon pienentäminen ja yleisesti kvanttiturvallisuuden parantaminen käyttäen eri lähestymistapoja ja uusia matemaattisia ideoita.

\section{Kvanttiturvallisen salauksen tulevaisuus}
Kappaleessa 3 puhuimme miten nykypäivän kvanttitietokoneet ovat vielä kehitysvaiheessa ja kuinka Shorin algoritmia käyttäen ei ole vielä saatu suuria kokonaislukuja jaettua tekijöihin. Vaikka suuren kokoluokan tehokkaat kvanttitietokoneet eivät vielä ole arkipäivää, tulisi kvanttiturvalliseen salaukseen kiinnittää huomiota jo nyt (\cite{ad93d053a85c4acebdd49cbe1a75d6bd}). Esimerkiksi joku pahantahtoinen hyökkääjä voisi kerätä salattua dataa talteen ja odottaa suuren kokoluokan kvanttitietokoneiden yleistymistä rauhassa tämän datan kanssa. Myöhemmin kvanttitietokoneiden yleistyessä, hyökkääjä voisi purkaa salatun datan käyttäen apunaan kvanttitietokonetta ja päästä käsiksi dataan. Tällaista hyökkäystä kutsutaan retrospektiiviseksi purkamiseksi (\emph{Retrospective decryption}).