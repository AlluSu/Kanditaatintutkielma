\chapter{Kvanttiturvallinen salaus\label{results}}
Seuraavaksi tutustumme muutamiin kvanttiturvallisiin salausmenetelmiin. Nämä salausmenetelmät ovat koodipohjainen, hilapohjainen ja monimuuttujapohjainen. Edellä mainittujen lisäksi on olemassa lähteistä riippuen muitakin salausmenetelmiä, mutta emme kuitenkaan tämän tutkielman laajuuden puitteissa perehdy aivan kaikkiin. Emme esimerkiksi käsittele elliptisiin käyriin perustuvia kvanttiturvallisia salausmenetelmiä (\emph{isogeny-based cryptography\footnote{Joissain lähteissä \emph{supersingular elliptic curve isogeny cryptography}}}) emmekä tiivistepohjaista salausta (\emph{hash-based cryptography}).

Käsittelemme kvanttiturvallisista salausmenetelmistä niiden idean sekä yleisiä ominaisuuksia muun muassa suorituskyvyssä ja julkisen avaimen koossa. Näitä eri kvanttiturvallisia salausmenetelmiä käyttäviä kvanttiturvallisia salausjärjestelmiä on implementoitu useita erilaisia. Näistä implementoiduista salausjärjestelmistä on taas monia erilaisia variantteja. Varianttien välillä on eroja, esimerkiksi joillain saadaan parempi suorituskyky, mutta vastapainona isompi julkisen avaimen koko tai toisin päin. Kuitenkin kaikkien niiden toiminta pohjautuu tässä esitellyihin ideoihin.

Tällä hetkellä tutkitaan ja kehitetään useita eri kvanttiturvallisia salausjärjestelmiä. \emph{National Institute of Standards and Technology (NIST)} ylläpitää prosessia, jossa etsitään kvanttiturvallisia julkisen avaimen salausjärjestelmiä, joista tulisi uusi kvanttiturvallinen standardi (\cite{alagic2020status}).

\section{Koodipohjainen salaus}
Koodipohjainen salaus (\emph{code-based cryptography}) perustuu Robert McEliecen artikkeliin \emph{A Public-Key Cryptosystem Based On Algebraic Coding Theory} vuodelta 1978 (\cite{8012331}). McEliecen esittelemässä salausjärjestelmässä salattavaa viestiä toistetaan monta kertaa putkeen, jonka jälkeen siihen lisätään tahallisesti virheitä. Näitä tahallaan lisättyjä virheitä kutsutaan virheenkorjauskoodeiksi (\emph{error-correction codes}). Tarkemmin ottaen McEliecen salausjärjestelmä käyttää lineaarisia virheenkorjauskoodeja, tarkennettuna binäärisia Goppa-koodeja.

Julkisena avaimena salausjärjestelmässä toimii niin kutsuttu kehitinmatriisi (\emph{generator matrix}). Kehitinmatriisi on jokin mielivaltainen kanta aiemmin mainituista virheenkorjauskoodeista. Formaalimmin kehitinmatriisi on 
\[k \times n  \; \text{matriisi} \; G \in \big\{0,1\big\}^{k \times n}\]
jonka jokainen rivi on lineaarisesti riippumaton (\emph{full-rank matrix}). Rivit muodostavat kannan $C$, jolloin 
\[C = \big\{ xG \: | \: x \in \big\{0,1\big\}^k \big\}.\]
Kuvaus
\[x \mapsto xG\]
laajentaa minkä tahansa \emph{k}-bittisen sanan \emph{n}-bittiseksi koodisanaksi.

Salausjärjestelmän turvallisuus perustuu siihen, että tällaisen salauksen purkaminen on yleisesti ottaen vaikeaa. Salatun viestin löytäminen kaiken muun virheellisen tiedon joukosta ei ole triviaalia. Salauksen purkaminen on todistettu NP-täydelliseksi ongelmaksi ja siten salausjärjestelmän uskotaan olevan kvanttitietokoneen kestävä. Lisäksi julkisen avaimen eli kehitinmatriisin erottaminen jostain toisesta satunnaisesta matriisista on hankalaa.

McEliecen esittämä salausjärjestelmä ja sen variantit ovat hyviä kandidaatteja kvanttiturvallisiksi julkisen avaimen salausjärjestelmiksi. Hyviä puolia ovat muun muassa laskennallinen tehokkuus viestiä salattaessa ja salausta purettaessa. Salaaminen ja purkaminen ovat nopeita ja melko yksinkertaisia operaatioita (\cite{mavroeidis2018impact}). Lisäksi salausjärjestelmä ja sen ideat ovat kehitelty pitkän aikaa sitten ja salausjärjestelmä on kestänyt hyvin aikaa ja tarkistelua yli neljänkymmenen vuoden ajan minkä takia salausjärjestelmä on ymmärretty hyvin (\cite{8012331}).

Puutteina koodipohjaisesta salausjärjestelmästä mainittakkoon, että digitaalisten allekirjoitusten tekemiseen se ei sovellu käytännössä. Toistaiseksi ei ole löydetty tai kehitetty allekirjoittamiseen soveltuvaa menetelmää joka olisi käytännöllinen. Joillain koodipohjaista salausta käyttävillä varianteilla saadaan allekirjoitus luotua, mutta se on kokoluokaltaan satoja kilotavuja eli hyvin suuri ja sitä kautta epäkäytännöllinen. Koodipohjainen salausjärjestelmä tuottaa kooltaan hyvin suuria julkisia avaimia jos käytetään kvanttiturvallista versiota. Tällöin avaimen koko voi olla väliltä 100 kilotavua aina useisiin megatavuihin (\cite{mavroeidis2018impact}). Suuret avainten koot voivat mahdollisesti rajoittaa salausjärjestelmän käyttöä esimerkiksi sulautetuissa järjestelmissä tai muissa järjestelmissä, jossa muistia on vähän ja resursseja rajoitetusti (\cite{8012331}). Kuitenkin McEliecen salausjärjestelmästä on olemassa variantteja, joissa on mahdollistettu pienempi avaimen koko kuten QC-MDPC (\emph{Quasicyclic Moderate Density Parity-Check Codes}). Lisäksi aiemmin mainittu turvallisuusseikka liittyen julkisen avaimen erottamiseen satunnaisesta matriisista on hieman avoin ongelma, joka vaatii lisää tutkimista ja enemmän formaalia todistuspohjaa. McEliecen salausjärjestelmä on turvallinen, koska siinä käytetään koodiperheenä aiemmin mainittuja binäärisia Goppa-koodeja. Muilla koodiperheillä salausjärjestelmä ei välttämättä ole turvallinen ja tämä kannattaa ottaa huomioon.

Classic McEliece on eräs koodipohjaiseen salaukseen perustuva kvanttiturvallinen julkisen avaimen salausjärjestelmä, joka perustuu edellä mainitun Robert McEliece ideoihin ja tutkimustuloksiin. (\cite{alagic2020status}). Classis McEliece on NIST:in standardointiprosessin kolmannen kierroksen finalisteista yksi neljästä kvanttiturvallisesta julkisen avaimen salausjärjestelmästä ja ainut koodipohjaiseen salaukseen perustuva.

\section{Hilapohjainen salaus}
Hilapohjainen salaus (\emph{lattice-based cryptography}) on kvanttiturvallinen salauksen muoto (\cite{regev2006lattice}). Hilapohjaisessa salauksessa salaus perustuu tiettyihin laskennallisesti vaativiin ongelmiin koskien hiloja. Hila on matemaattinen objekti, joka kuvataan joukkona pisteitä \emph{n}-ulotteisessa avaruudessa ja sillä on jonkinlainen jaksollinen rakenne. Formaalimmin hila on \emph{n}:stä lineaarisesti riippumattomasta vektorista muodostuva joukko vektoreita 
\[L(v_1, \ldots ,v_n) =\Bigg\{ {\sum_{i=1}^{n}\alpha_i 
v_i|\alpha_i \in \mathbb{Z}} \Bigg\},\]
missä vektorit $v_1, \ldots ,v_n$ ovat hilan kanta.

Monissa hiloihin liittyvissä 
laskennallisissa ongelmissa ollaan kiinnostuneita löytämään jokin lyhin vektori tai vektoreita. Lyhimmän vektorin ongelma (\emph{SVP, Shortest Vector Problem)} on yleinen esimerkki laskennallisesta ongelmasta kun puhutaan hiloista. \emph{SVP}:ssä annetaan hilan kanta ja tehtävän on määritellä lyhin vektori hilassa, joka ei ole nollavektori. \emph{SVP}:n haastavuus piilee siinä, että hilalla on monta eri kantaa ja hilan kanta koostuu erittäin pitkistä vektoreista.

Hilapohjaisessa salauksessa huomattavaa on se miten salauksen vahvuus perustuu ongelmien pahimman tapauksen mukaan (\emph{worst-case hardness}). Esimerkiksi nykyisissä salausjärjestelmissä käyettävää suurten alkulukujen tekijöihin jakamisen vaikeutta kuvataan keskimääräisen tapauksen mukaan (\emph{average-case hardness}). Tämä tarkoittaa käytännössä sitä, että alkulukujen tekijöihinjako on helppo laskennallinen ongelma, jos tekijät ovat esimerkiksi pieniä tai parillisia lukuja. Tekijöihinjako taas vaikeutuu, jos luvut ovat hyvin suuria. Tällaista ilmiöitä ei esiinny hilojen kanssa, että olisi jokin tietty jakauma mikä määrittelee onko ongelma laskennallisesti helppo vai vaikea.

Hilapohjaisen salauksen hyviä puolia ovat muun muassa salaukseen tarvittavan laskennan yksinkertaisuus, koska ne vaativat usein vain modulaariartimetiikkaa (\cite{regev2006lattice}). Tämä on eduksi silloin jos resursseja kuten muistia ja laskentatehoa on rajoitetusti kuten esimerkiksi sulautetuissa järjestelmissä.

Huonona puolena hilapohjaisessa salauksessa on se, että salatun viestin koko kasvaa noin 30-kertaiseksi verrattuna alkuperäiseen salaamattomaan viestiin (\cite{8275352}). Esimerkiksi \emph{Ring-LWE} on eräs hilapohjainen julkisen avaimen salausjärjestelmä, joka kasvattaa salatessaan 128-tavuisen salaamattoman viestin 4096-tavuiseksi. Nykyisissä julkisen avaimen salausjärjestelmissä salaamattoman ja salatun viestin koko on täysin sama.

Hiloihin perustuviin ongelmiin ei ole tällä hetkellä tiedossa olevia kvanttialgoritmeja mikä tekee siitä luonnollisesti oivallisen kvanttiturvallisen salausmenetelmän (\cite{regev2006lattice}). NIST:in kvanttiturvallisten julkisen avaimen salausjärjestelmien standardointiprosessissa kolme neljästä kolmannen kierroksen finalistista ovat hilapohjaiseen salaukseen perustuvia (\cite{alagic2020status}). Yksi näistä finalisteista on nimeltään NTRU, joka on osoittautunut tehokkaaksi ja turvalliseksi salausjärjestelmäksi. NTRU:sta povataankin standardointikierroksen finalistia.

\section{Monimuuttujapohjainen salaus}
Monimuuttujapohjainen salaus (\emph{multivariate-based cryptography}) on eräs kvanttiturvallisen salauksen muoto. Monimuuttujapohjaista salausta käytetään monimuuttujapohjaisen julkisen avaimen salausjärjestelmän muodostamiseen (\emph{Multivariate public key cryptosystem}) (\cite{Ding2009}). Monimuuttujapohjainen salaus perustuu monta muuttujaa sisältävien yhtälöryhmien ratkaisun vaikeuteen. Yhtälöryhmien yhtälöt ovat neliöllisiä eli epälineaarisia äärellisessä kunnassa.

Monimuuttujapohjaisessa julkisen avaimen salausjärjestelmässä julkinen avain on yhtälöryhmä neliöllisiä polynomeja, joissa on monta muuttujaa pienessä äärellisessä kunnassa \emph{K} (\cite{8012305}). Esimerkkinä: 
    \begin{align*}
        p^{(1)}(x_{1}...,x_{n}) &= \sum_{i=1}^{n} p_{ij}^{(1)}x_{i}x_ {j}+\sum_{i=1}^{n}p_ {i}^{(1)}x_{i}+p_ {0}^{(1)} \\
        p^{(2)}(x_{1}...,x_{n}) &= \sum_{i=1}^{n} p_{ij}^{(2)}x_{i}x_ {j}+\sum_{i=1}^{n}p_ {i}^{(2)}x_{i}+p_ {0}^{(2)} \\
        \vdots \\
        p^{(m)}(x_{1}...,x_{n}) &= \sum_{i=1}^{n} p_{ij}^{(m)}x_{i}x_ {j}+\sum_{i=1}^{n}p_ {i}^{(m)}x_{i}+p_ {0}^{(m)}
    \end{align*}
Tällaisen julkisen avaimen salausjärjestelmän turvallisuus perustuu niin kutsuttuun \emph{MQ}-ongelmaan (\emph{Multivariate quadratic polynomial problem}).

\emph{MQ}-ongelma: Ratkaise yhtälöryhmä $p_{1}(x) = p_{2}(x) = ... = p_ {m}(x) = 0$, missä jokainen $p_{i}$ on neliöllinen joukossa $x = (x_{1}, ..., x_{n})$ (\cite{Ding2009}).

\emph{MQ}-ongelma on todistettu NP-kovaksi ongelmaksi jokaisessa kunnassa ja sen uskotaan siten olevan vaikea ongelma myös kvanttitietokoneille (\cite{8012305}). Tähän perustuu monimuuttujapohjaisen julkisen avaimen salausjärjestelmän suojaus.

Monimuuttujapohjaisissa salausjärjestelmissä huonona puolena on niiden tuottamien avainten suuret koot. Keskimäärin monimuuttujapohjaiset salausjärjestelmät luovat julkisen avaimen, jonka koko on väliltä 10--100 kilotavua. \emph{Rainbow} on yksi NIST:in tutkima ehdokas, josta voisi tulla uusi kvanttiturvallinen standardi allekirjoitusten tekoon. (\cite{alagic2020status}). \emph{Rainbow} on monimuuttujapohjainen allekirjoittamiseen luotu järjestelmä, joka tuottaa julkisen avaimen, joka on kooltaan yli 16 kilotavua (\cite{Ding2009}). Nämä suuret avainten koot saattavat tuottaa ongelmia muun muassa sulautetuissa järjestelmissä tai järjestelmissä, joissa verkkoyhteydet ovat hyvin rajoittuneet ja jossa avaimia pitäisi lähettää monta kertaa verkon yli (\cite{8012305}). Lisäksi monimuuttujapohjaisen salauksen parissa on salausjärjestelmiä, joiden kvanttiturvallisuutta ei ole formaalisti todistettu ja sieltä puuttuu formaalia teoriapohjaa. Kuitenkin käytännössä useat monimuuttujapohjaiset salausjärjestelmät ovat pysyneet turvallisina erilaisia hyökkäyksiä vastaan, vaikka formaali teoriapohja puuttuu.

Monimuuttujapohjaisessa salausjärjestelmässä on myös paljon hyviä puolia. Monimuuttujapohjaiset salausjärjestelmät voidaan implementoida tehokkaiksi, jolloin ne ovat nopeampia kuin muut kvanttiturvallisest salausjärjestelmät. Monimuuttujapohjaiset salausjärjestelmät vaativat kohtuullisesti laskentatehoa, jolloin sovelluskohteita voi löytyä IoT:n parista. Ne käyttävät ainoastaan aritmeettisia laskuoperaatioita kuten kertolaskua ja yhteenlaskua. Tällöin niitä voi hyödyntää laitteissa, joissa ei ole paljoa resursseja saatavilla, kuten esimerkiksi sirukorteissa ja RFID-teknologiaa käyttävissä siruissa. Lisäksi monimuuttujapohjaiset allekirjoitusmenetelmät luovat pituudeltaan hyvin lyhyitä allekirjoituksia verrattuna esimerkiksi klassisiin tai muihin kvanttiturvallisiin allekirjoituksiin.
